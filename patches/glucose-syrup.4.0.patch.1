diff -rupN glucose-syrup/Changelog glucose-syrup.modified/Changelog
--- glucose-syrup/Changelog	1970-01-01 01:00:00.000000000 +0100
+++ glucose-syrup.modified/Changelog	2014-10-03 11:10:21.000000000 +0200
@@ -0,0 +1,27 @@
+Version 4.0
+ - Add a Multithread version, called syrup (many glucose ;-)
+   See SAT14 paper: Lazy Clause Exchange Policy for parallel SAT solvers.
+
+ - Can work indepentently in sequential or with many cores
+
+Version 3.0 (2013)
+ - Add incremental features. 
+    See SAT13 paper: Improving Glucose for Incremental SAT Solving with Assumptions: Application to MUS Extraction
+
+ - Add certified UNSAT proof.
+
+Version 2.3 (2012)
+ - Add new restart strategy 
+    See CP12 paper: Refining Restarts Strategies For SAT and UNSAT
+
+ - Add additionnal features to speed the search
+
+Version 2.0 (2011) 
+ - Add additionnal features (freeze potential good clauses for one turn)
+
+ - Based on Minisat 2.2
+
+Version 1.0 (2009)
+ - Based on Minisat 2.0
+    First release of glucose.
+    See ijcai 2009 paper: Predicting Learnt Clauses Quality in Modern SAT Solver
\ No newline at end of file
diff -rupN glucose-syrup/LICENCE glucose-syrup.modified/LICENCE
--- glucose-syrup/LICENCE	1970-01-01 01:00:00.000000000 +0100
+++ glucose-syrup.modified/LICENCE	2014-10-03 11:10:22.000000000 +0200
@@ -0,0 +1,47 @@
+ Glucose -- Copyright (c) 2009-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                LRI  - Univ. Paris Sud, France (2009-2013)
+                                Labri - Univ. Bordeaux, France
+
+ Syrup (Glucose Parallel) -- Copyright (c) 2013-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                Labri - Univ. Bordeaux, France
+
+Glucose sources are based on MiniSat (see below MiniSat copyrights). Permissions and copyrights of
+Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it 
+is based on. (see below).
+
+Glucose-Syrup sources are based on another copyright. Permissions and copyrights for the parallel
+version of Glucose-Syrup (the "Software") are granted, free of charge, to deal with the Software
+without restriction, including the rights to use, copy, modify, merge, publish, distribute,
+sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is 
+furnished to do so, subject to the following conditions:
+
+- The above and below copyrights notices and this permission notice shall be included in all
+copies or substantial portions of the Software;
+- The parallel version of Glucose (all files modified since Glucose 3.0 releases, 2013) cannot
+be used in any competitive event (sat competitions/evaluations) without the express permission of 
+the authors (Gilles Audemard / Laurent Simon). This is also the case for any competitive event
+using Glucose Parallel as an embedded SAT engine (single core or not).
+
+
+--------------- Original Minisat Copyrights
+
+Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+Copyright (c) 2007-2010, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
diff -rupN glucose-syrup/LICENSE glucose-syrup.modified/LICENSE
--- glucose-syrup/LICENSE	2014-11-24 15:54:11.963436385 +0100
+++ glucose-syrup.modified/LICENSE	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
-           Copyright (c) 2007-2010  Niklas Sorensson
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff -rupN glucose-syrup/README glucose-syrup.modified/README
--- glucose-syrup/README	2014-11-24 15:54:11.967436464 +0100
+++ glucose-syrup.modified/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-================================================================================
-DIRECTORY OVERVIEW:
-
-mtl/            Mini Template Library
-utils/          Generic helper code (I/O, Parsing, CPU-time, etc)
-core/           A core version of the solver
-simp/           An extended solver with simplification capabilities
-README
-LICENSE
-
-================================================================================
-BUILDING: (release version: without assertions, statically linked, etc)
-
-export MROOT=<minisat-dir>              (or setenv in cshell)
-cd { core | simp }
-gmake rs
-cp minisat_static <install-dir>/minisat
-
-================================================================================
-EXAMPLES:
-
-Run minisat with same heuristics as version 2.0:
-
-> minisat <cnf-file> -no-luby -rinc=1.5 -phase-saving=0 -rnd-freq=0.02
diff -rupN glucose-syrup/core/BoundedQueue.h glucose-syrup.modified/core/BoundedQueue.h
--- glucose-syrup/core/BoundedQueue.h	2014-11-24 15:54:11.967436464 +0100
+++ glucose-syrup.modified/core/BoundedQueue.h	2014-10-03 11:10:21.000000000 +0200
@@ -1,23 +1,51 @@
-/***********************************************************************************[BoundedQueue.h]
- Glucose -- Copyright (c) 2009, Gilles Audemard, Laurent Simon
-                CRIL - Univ. Artois, France
-                LRI  - Univ. Paris Sud, France
- 
+/***************************************************************************************[BoundedQueue.h]
+ Glucose -- Copyright (c) 2009-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                LRI  - Univ. Paris Sud, France (2009-2013)
+                                Labri - Univ. Bordeaux, France
+
+ Syrup (Glucose Parallel) -- Copyright (c) 2013-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                Labri - Univ. Bordeaux, France
+
+Glucose sources are based on MiniSat (see below MiniSat copyrights). Permissions and copyrights of
+Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it 
+is based on. (see below).
+
+Glucose-Syrup sources are based on another copyright. Permissions and copyrights for the parallel
+version of Glucose-Syrup (the "Software") are granted, free of charge, to deal with the Software
+without restriction, including the rights to use, copy, modify, merge, publish, distribute,
+sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is 
+furnished to do so, subject to the following conditions:
+
+- The above and below copyrights notices and this permission notice shall be included in all
+copies or substantial portions of the Software;
+- The parallel version of Glucose (all files modified since Glucose 3.0 releases, 2013) cannot
+be used in any competitive event (sat competitions/evaluations) without the express permission of 
+the authors (Gilles Audemard / Laurent Simon). This is also the case for any competitive event
+using Glucose Parallel as an embedded SAT engine (single core or not).
+
+
+--------------- Original Minisat Copyrights
+
+Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+Copyright (c) 2007-2010, Niklas Sorensson
+
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 associated documentation files (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge, publish, distribute,
 sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
- 
+
 The above copyright notice and this permission notice shall be included in all copies or
 substantial portions of the Software.
- 
+
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
 NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-**************************************************************************************************/
+ **************************************************************************************************/
 
 
 #ifndef BoundedQueue_h
@@ -102,7 +130,17 @@ public:
 
     void clear(bool dealloc = false)   { elems.clear(dealloc); first = 0; maxsize=0; queuesize=0;sumofqueue=0;}
 
-
+    void copyTo(bqueue &dest) const {
+        dest.last = last;
+        dest.sumofqueue = sumofqueue;
+        dest.maxsize = maxsize;
+        dest.queuesize = queuesize;
+        dest.expComputed = expComputed;
+        dest.exp = exp;
+        dest.value = value;
+        dest.first = first;        
+        elems.copyTo(dest.elems);
+    }
 };
 }
 //=================================================================================================
diff -rupN glucose-syrup/core/Constants.h glucose-syrup.modified/core/Constants.h
--- glucose-syrup/core/Constants.h	2014-11-24 15:54:11.967436464 +0100
+++ glucose-syrup.modified/core/Constants.h	2014-10-03 11:10:21.000000000 +0200
@@ -1,33 +1,59 @@
-/************************************************************************************[Constants.h]
- Glucose -- Copyright (c) 2009, Gilles Audemard, Laurent Simon
-                CRIL - Univ. Artois, France
-                LRI  - Univ. Paris Sud, France
-  
+/***************************************************************************************[Constants.h]
+ Glucose -- Copyright (c) 2009-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                LRI  - Univ. Paris Sud, France (2009-2013)
+                                Labri - Univ. Bordeaux, France
+
+ Syrup (Glucose Parallel) -- Copyright (c) 2013-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                Labri - Univ. Bordeaux, France
+
+Glucose sources are based on MiniSat (see below MiniSat copyrights). Permissions and copyrights of
+Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it 
+is based on. (see below).
+
+Glucose-Syrup sources are based on another copyright. Permissions and copyrights for the parallel
+version of Glucose-Syrup (the "Software") are granted, free of charge, to deal with the Software
+without restriction, including the rights to use, copy, modify, merge, publish, distribute,
+sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is 
+furnished to do so, subject to the following conditions:
+
+- The above and below copyrights notices and this permission notice shall be included in all
+copies or substantial portions of the Software;
+- The parallel version of Glucose (all files modified since Glucose 3.0 releases, 2013) cannot
+be used in any competitive event (sat competitions/evaluations) without the express permission of 
+the authors (Gilles Audemard / Laurent Simon). This is also the case for any competitive event
+using Glucose Parallel as an embedded SAT engine (single core or not).
+
+
+--------------- Original Minisat Copyrights
+
+Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+Copyright (c) 2007-2010, Niklas Sorensson
+
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 associated documentation files (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge, publish, distribute,
 sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
- 
+
 The above copyright notice and this permission notice shall be included in all copies or
 substantial portions of the Software.
- 
+
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
 NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-**************************************************************************************************/
+ **************************************************************************************************/
 
 #define DYNAMICNBLEVEL
 #define CONSTANTREMOVECLAUSE
-#define UPDATEVARACTIVITY
 
 // Constants for clauses reductions
 #define RATIOREMOVECLAUSES 2
 
 
-
 // Constants for restarts
 #define LOWER_BOUND_FOR_BLOCKING_RESTART 10000
 
diff -rupN glucose-syrup/core/Solver.cc glucose-syrup.modified/core/Solver.cc
--- glucose-syrup/core/Solver.cc	2014-11-24 16:18:30.760505237 +0100
+++ glucose-syrup.modified/core/Solver.cc	2014-11-25 17:14:44.550232674 +0100
@@ -1,12 +1,32 @@
 /***************************************************************************************[Solver.cc]
- Glucose -- Copyright (c) 2013, Gilles Audemard, Laurent Simon
-				CRIL - Univ. Artois, France
-				LRI  - Univ. Paris Sud, France
- 
+ Glucose -- Copyright (c) 2009-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                LRI  - Univ. Paris Sud, France (2009-2013)
+                                Labri - Univ. Bordeaux, France
+
+ Syrup (Glucose Parallel) -- Copyright (c) 2013-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                Labri - Univ. Bordeaux, France
+
 Glucose sources are based on MiniSat (see below MiniSat copyrights). Permissions and copyrights of
-Glucose are exactly the same as Minisat on which it is based on. (see below).
+Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it 
+is based on. (see below).
+
+Glucose-Syrup sources are based on another copyright. Permissions and copyrights for the parallel
+version of Glucose-Syrup (the "Software") are granted, free of charge, to deal with the Software
+without restriction, including the rights to use, copy, modify, merge, publish, distribute,
+sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is 
+furnished to do so, subject to the following conditions:
+
+- The above and below copyrights notices and this permission notice shall be included in all
+copies or substantial portions of the Software;
+- The parallel version of Glucose (all files modified since Glucose 3.0 releases, 2013) cannot
+be used in any competitive event (sat competitions/evaluations) without the express permission of 
+the authors (Gilles Audemard / Laurent Simon). This is also the case for any competitive event
+using Glucose Parallel as an embedded SAT engine (single core or not).
 
----------------
+
+--------------- Original Minisat Copyrights
 
 Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
 Copyright (c) 2007-2010, Niklas Sorensson
@@ -25,14 +45,14 @@ NOT LIMITED TO THE WARRANTIES OF MERCHAN
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-**************************************************************************************************/
+ **************************************************************************************************/
 
 #include <math.h>
 
+#include "utils/System.h"
 #include "mtl/Sort.h"
 #include "core/Solver.h"
 #include "core/Constants.h"
-#include "utils/System.h"
 
 using namespace Glucose;
 
@@ -43,128 +63,225 @@ static const char* _cat = "CORE";
 static const char* _cr = "CORE -- RESTART";
 static const char* _cred = "CORE -- REDUCE";
 static const char* _cm = "CORE -- MINIMIZE";
-static const char* _certified = "CORE -- CERTIFIED UNSAT";
-
 
 
 
-static BoolOption opt_incremental (_cat,"incremental", "Use incremental SAT solving",false);
-static DoubleOption opt_K                 (_cr, "K",           "The constant used to force restart",            0.8,     DoubleRange(0, false, 1, false));           
-static DoubleOption opt_R                 (_cr, "R",           "The constant used to block restart",            1.4,     DoubleRange(1, false, 5, false));           
-static IntOption     opt_size_lbd_queue     (_cr, "szLBDQueue",      "The size of moving average for LBD (restarts)", 50, IntRange(10, INT32_MAX));
-static IntOption     opt_size_trail_queue     (_cr, "szTrailQueue",      "The size of moving average for trail (block restarts)", 5000, IntRange(10, INT32_MAX));
 
-static IntOption     opt_first_reduce_db     (_cred, "firstReduceDB",      "The number of conflicts before the first reduce DB", 2000, IntRange(0, INT32_MAX));
-static IntOption     opt_inc_reduce_db     (_cred, "incReduceDB",      "Increment for reduce DB", 300, IntRange(0, INT32_MAX));
-static IntOption     opt_spec_inc_reduce_db     (_cred, "specialIncReduceDB",      "Special increment for reduce DB", 1000, IntRange(0, INT32_MAX));
-static IntOption    opt_lb_lbd_frozen_clause      (_cred, "minLBDFrozenClause",        "Protect clauses if their LBD decrease and is lower than (for one turn)", 30, IntRange(0, INT32_MAX));
-
-static IntOption     opt_lb_size_minimzing_clause     (_cm, "minSizeMinimizingClause",      "The min size required to minimize clause", 30, IntRange(3, INT32_MAX));
-static IntOption     opt_lb_lbd_minimzing_clause     (_cm, "minLBDMinimizingClause",      "The min LBD required to minimize clause", 6, IntRange(3, INT32_MAX));
-
-
-static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.8,     DoubleRange(0, false, 1, false));
-static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
-static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
-static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));
-static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
-static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
-static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);
-/*
-static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
-static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
-*/
-static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
-
-
- BoolOption    opt_certified      (_certified, "certified",    "Certified UNSAT using DRUP format", false);
- StringOption    opt_certified_file      (_certified, "certified-output",    "Certified UNSAT output file", "NULL");
+static DoubleOption opt_K(_cr, "K", "The constant used to force restart", 0.8, DoubleRange(0, false, 1, false));
+static DoubleOption opt_R(_cr, "R", "The constant used to block restart", 1.4, DoubleRange(1, false, 5, false));
+static IntOption opt_size_lbd_queue(_cr, "szLBDQueue", "The size of moving average for LBD (restarts)", 50, IntRange(10, INT32_MAX));
+static IntOption opt_size_trail_queue(_cr, "szTrailQueue", "The size of moving average for trail (block restarts)", 5000, IntRange(10, INT32_MAX));
+
+static IntOption opt_first_reduce_db(_cred, "firstReduceDB", "The number of conflicts before the first reduce DB", 2000, IntRange(0, INT32_MAX));
+static IntOption opt_inc_reduce_db(_cred, "incReduceDB", "Increment for reduce DB", 300, IntRange(0, INT32_MAX));
+static IntOption opt_spec_inc_reduce_db(_cred, "specialIncReduceDB", "Special increment for reduce DB", 1000, IntRange(0, INT32_MAX));
+static IntOption opt_lb_lbd_frozen_clause(_cred, "minLBDFrozenClause", "Protect clauses if their LBD decrease and is lower than (for one turn)", 30, IntRange(0, INT32_MAX));
+
+static IntOption opt_lb_size_minimzing_clause(_cm, "minSizeMinimizingClause", "The min size required to minimize clause", 30, IntRange(3, INT32_MAX));
+static IntOption opt_lb_lbd_minimzing_clause(_cm, "minLBDMinimizingClause", "The min LBD required to minimize clause", 6, IntRange(3, INT32_MAX));
+
+
+static DoubleOption opt_var_decay(_cat, "var-decay", "The variable activity decay factor (starting point)", 0.8, DoubleRange(0, false, 1, false));
+static DoubleOption opt_max_var_decay(_cat, "max-var-decay", "The variable activity decay factor", 0.95, DoubleRange(0, false, 1, false));
+static DoubleOption opt_clause_decay(_cat, "cla-decay", "The clause activity decay factor", 0.999, DoubleRange(0, false, 1, false));
+static DoubleOption opt_random_var_freq(_cat, "rnd-freq", "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
+static DoubleOption opt_random_seed(_cat, "rnd-seed", "Used by the random variable selection", 91648253, DoubleRange(0, false, HUGE_VAL, false));
+static IntOption opt_ccmin_mode(_cat, "ccmin-mode", "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
+static IntOption opt_phase_saving(_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
+static BoolOption opt_rnd_init_act(_cat, "rnd-init", "Randomize the initial activity", false);
+static DoubleOption opt_garbage_frac(_cat, "gc-frac", "The fraction of wasted memory allowed before a garbage collection is triggered", 0.20, DoubleRange(0, false, HUGE_VAL, false));
 
 
 //=================================================================================================
 // Constructor/Destructor:
 
-
 Solver::Solver() :
 
-    // Parameters (user settable):
-    //
-    verbosity        (0)
-    , showModel        (0)
-    , K              (opt_K)
-    , R              (opt_R)
-    , sizeLBDQueue   (opt_size_lbd_queue)
-    , sizeTrailQueue   (opt_size_trail_queue)
-    , firstReduceDB  (opt_first_reduce_db)
-    , incReduceDB    (opt_inc_reduce_db)
-    , specialIncReduceDB    (opt_spec_inc_reduce_db)
-    , lbLBDFrozenClause (opt_lb_lbd_frozen_clause)
-    , lbSizeMinimizingClause (opt_lb_size_minimzing_clause)
-    , lbLBDMinimizingClause (opt_lb_lbd_minimzing_clause)
-  , var_decay        (opt_var_decay)
-  , clause_decay     (opt_clause_decay)
-  , random_var_freq  (opt_random_var_freq)
-  , random_seed      (opt_random_seed)
-  , ccmin_mode       (opt_ccmin_mode)
-  , phase_saving     (opt_phase_saving)
-  , rnd_pol          (false)
-  , rnd_init_act     (opt_rnd_init_act)
-  , garbage_frac     (opt_garbage_frac)
-  , certifiedOutput  (NULL)
-  , certifiedUNSAT   (opt_certified) 
-    // Statistics: (formerly in 'SolverStats')
-    //
-  ,  nbRemovedClauses(0),nbReducedClauses(0), nbDL2(0),nbBin(0),nbUn(0) , nbReduceDB(0)
-    , solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0),conflicts(0),conflictsRestarts(0),nbstopsrestarts(0),nbstopsrestartssame(0),lastblockatrestart(0)
-  , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
-    , curRestart(1)
-
-  , ok                 (true)
-  , cla_inc            (1)
-  , var_inc            (1)
-  , watches            (WatcherDeleted(ca))
-  , watchesBin            (WatcherDeleted(ca))
-  , qhead              (0)
-  , simpDB_assigns     (-1)
-  , simpDB_props       (0)
-  , order_heap         (VarOrderLt(activity))
-  , progress_estimate  (0)
-  , remove_satisfied   (true)
-
-    // Resource constraints:
-    //
-  , conflict_budget    (-1)
-  , propagation_budget (-1)
-  , asynch_interrupt   (false)
-  , incremental(opt_incremental)
-  , nbVarsInitialFormula(INT32_MAX)
-{
-  MYFLAG=0;  
-  // Initialize only first time. Useful for incremental solving, useless otherwise
-  lbdQueue.initSize(sizeLBDQueue);
-  trailQueue.initSize(sizeTrailQueue);
-  sumLBD = 0;
-  nbclausesbeforereduce = firstReduceDB;
-  totalTime4Sat=0;totalTime4Unsat=0;
-  nbSatCalls=0;nbUnsatCalls=0;
+// Parameters (user settable):
+//
+verbosity(0)
+, showModel(0)
+, K(opt_K)
+, R(opt_R)
+, sizeLBDQueue(opt_size_lbd_queue)
+, sizeTrailQueue(opt_size_trail_queue)
+, firstReduceDB(opt_first_reduce_db)
+, incReduceDB(opt_inc_reduce_db)
+, specialIncReduceDB(opt_spec_inc_reduce_db)
+, lbLBDFrozenClause(opt_lb_lbd_frozen_clause)
+, lbSizeMinimizingClause(opt_lb_size_minimzing_clause)
+, lbLBDMinimizingClause(opt_lb_lbd_minimzing_clause)
+, var_decay(opt_var_decay)
+, max_var_decay(opt_max_var_decay)
+, clause_decay(opt_clause_decay)
+, random_var_freq(opt_random_var_freq)
+, random_seed(opt_random_seed)
+, ccmin_mode(opt_ccmin_mode)
+, phase_saving(opt_phase_saving)
+, rnd_pol(false)
+, rnd_init_act(opt_rnd_init_act)
+, garbage_frac(opt_garbage_frac)
+, certifiedOutput(NULL)
+, certifiedUNSAT(false) // Not in the first parallel version 
+, panicModeLastRemoved(0), panicModeLastRemovedShared(0)
+, useUnaryWatched(false)
+, promoteOneWatchedClause(true)
+// Statistics: (formerly in 'SolverStats')
+//
+, nbPromoted(0)
+, originalClausesSeen(0)
+, sumDecisionLevels(0)
+, nbRemovedClauses(0), nbRemovedUnaryWatchedClauses(0), nbReducedClauses(0), nbDL2(0), nbBin(0), nbUn(0), nbReduceDB(0)
+, solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0), conflictsRestarts(0)
+, nbstopsrestarts(0), nbstopsrestartssame(0), lastblockatrestart(0)
+, dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
+, curRestart(1)
+
+, ok(true)
+, cla_inc(1)
+, var_inc(1)
+, watches(WatcherDeleted(ca))
+, watchesBin(WatcherDeleted(ca))
+, unaryWatches(WatcherDeleted(ca))
+, qhead(0)
+, simpDB_assigns(-1)
+, simpDB_props(0)
+, order_heap(VarOrderLt(activity))
+, progress_estimate(0)
+, remove_satisfied(true)
+, reduceOnSize(false) // 
+, reduceOnSizeSize(12) // Constant to use on size reductions
+,lastLearntClause(CRef_Undef)
+// Resource constraints:
+//
+, conflict_budget(-1)
+, propagation_budget(-1)
+, asynch_interrupt(false)
+, incremental(false)
+, nbVarsInitialFormula(INT32_MAX)
+, totalTime4Sat(0.)
+, totalTime4Unsat(0.)
+, nbSatCalls(0)
+, nbUnsatCalls(0)
+{
+    MYFLAG = 0;
+    // Initialize only first time. Useful for incremental solving (not in // version), useless otherwise
+    // Kept here for simplicity
+    lbdQueue.initSize(sizeLBDQueue);
+    trailQueue.initSize(sizeTrailQueue);
+    sumLBD = 0;
+    nbclausesbeforereduce = firstReduceDB;
+}
+
+//-------------------------------------------------------
+// Special constructor used for cloning solvers
+//-------------------------------------------------------
+
+Solver::Solver(const Solver &s) :
+  verbosity(s.verbosity)
+, showModel(s.showModel)
+, K(s.K)
+, R(s.R)
+, sizeLBDQueue(s.sizeLBDQueue)
+, sizeTrailQueue(s.sizeTrailQueue)
+, firstReduceDB(s.firstReduceDB)
+, incReduceDB(s.incReduceDB)
+, specialIncReduceDB(s.specialIncReduceDB)
+, lbLBDFrozenClause(s.lbLBDFrozenClause)
+, lbSizeMinimizingClause(s.lbSizeMinimizingClause)
+, lbLBDMinimizingClause(s.lbLBDMinimizingClause)
+, var_decay(s.var_decay)
+, max_var_decay(s.max_var_decay)
+, clause_decay(s.clause_decay)
+, random_var_freq(s.random_var_freq)
+, random_seed(s.random_seed)
+, ccmin_mode(s.ccmin_mode)
+, phase_saving(s.phase_saving)
+, rnd_pol(s.rnd_pol)
+, rnd_init_act(s.rnd_init_act)
+, garbage_frac(s.garbage_frac)
+, certifiedOutput(NULL)
+, certifiedUNSAT(false) // Not in the first parallel version 
+, panicModeLastRemoved(s.panicModeLastRemoved), panicModeLastRemovedShared(s.panicModeLastRemovedShared)
+, useUnaryWatched(s.useUnaryWatched)
+, promoteOneWatchedClause(s.promoteOneWatchedClause)
+// Statistics: (formerly in 'SolverStats')
+//
+, nbPromoted(s.nbPromoted)
+, originalClausesSeen(s.originalClausesSeen)
+, sumDecisionLevels(s.sumDecisionLevels)
+, nbRemovedClauses(s.nbRemovedClauses), nbRemovedUnaryWatchedClauses(s.nbRemovedUnaryWatchedClauses)
+, nbReducedClauses(s.nbReducedClauses), nbDL2(s.nbDL2), nbBin(s.nbBin), nbUn(s.nbUn), nbReduceDB(s.nbReduceDB)
+, solves(s.solves), starts(s.starts), decisions(s.decisions), rnd_decisions(s.rnd_decisions)
+, propagations(s.propagations), conflicts(s.conflicts), conflictsRestarts(s.conflictsRestarts)
+, nbstopsrestarts(s.nbstopsrestarts), nbstopsrestartssame(s.nbstopsrestartssame)
+, lastblockatrestart(s.lastblockatrestart)
+, dec_vars(s.dec_vars), clauses_literals(s.clauses_literals)
+, learnts_literals(s.learnts_literals), max_literals(s.max_literals), tot_literals(s.tot_literals)
+, curRestart(s.curRestart)
+
+, ok(true)
+, cla_inc(s.cla_inc)
+, var_inc(s.var_inc)
+, watches(WatcherDeleted(ca))
+, watchesBin(WatcherDeleted(ca))
+, unaryWatches(WatcherDeleted(ca))
+, qhead(s.qhead)
+, simpDB_assigns(s.simpDB_assigns)
+, simpDB_props(s.simpDB_props)
+, order_heap(VarOrderLt(activity))
+, progress_estimate(s.progress_estimate)
+, remove_satisfied(s.remove_satisfied)
+, reduceOnSize(s.reduceOnSize) // 
+, reduceOnSizeSize(s.reduceOnSizeSize) // Constant to use on size reductions
+,lastLearntClause(CRef_Undef)
+// Resource constraints:
+//
+, conflict_budget(s.conflict_budget)
+, propagation_budget(s.propagation_budget)
+, asynch_interrupt(s.asynch_interrupt)
+, incremental(s.incremental)
+, nbVarsInitialFormula(s.nbVarsInitialFormula)
+, totalTime4Sat(s.totalTime4Sat)
+, totalTime4Unsat(s.totalTime4Unsat)
+, nbSatCalls(s.nbSatCalls)
+, nbUnsatCalls(s.nbUnsatCalls)
+{
+    // Copy clauses.
+    s.ca.copyTo(ca);
+    ca.extra_clause_field = s.ca.extra_clause_field;
+
+    // Initialize  other variables
+     MYFLAG = 0;
+    // Initialize only first time. Useful for incremental solving (not in // version), useless otherwise
+    // Kept here for simplicity
+    sumLBD = s.sumLBD;
+    nbclausesbeforereduce = s.nbclausesbeforereduce;
+   
+    // Copy all search vectors
+    s.watches.copyTo(watches);
+    s.watchesBin.copyTo(watchesBin);
+    s.unaryWatches.copyTo(unaryWatches);
+    s.assigns.memCopyTo(assigns);
+    s.vardata.memCopyTo(vardata);
+    s.activity.memCopyTo(activity);
+    s.seen.memCopyTo(seen);
+    s.permDiff.memCopyTo(permDiff);
+    s.polarity.memCopyTo(polarity);
+    s.decision.memCopyTo(decision);
+    s.trail.memCopyTo(trail);
+    s.order_heap.copyTo(order_heap);
+    s.clauses.memCopyTo(clauses);
+    s.learnts.memCopyTo(learnts);
 
+    s.lbdQueue.copyTo(lbdQueue);
+    s.trailQueue.copyTo(trailQueue);
 
-  if(certifiedUNSAT) {
-    if(!strcmp(opt_certified_file,"NULL")) {
-      certifiedOutput =  fopen("/dev/stdout", "wb");
-    } else {
-      certifiedOutput =  fopen(opt_certified_file, "wb");	    
-    }
-    //    fprintf(certifiedOutput,"o proof DRUP\n");
-  }
 }
 
-
-Solver::~Solver()
-{
+Solver::~Solver() {
 }
 
-
 /****************************************************************
  Set the incremental mode
 ****************************************************************/
@@ -181,6 +298,10 @@ void Solver::initNbInitialVars(int nb) {
   nbVarsInitialFormula = nb;
 }
 
+bool Solver::isIncremental() {
+  return incremental;
+}
+
 
 //=================================================================================================
 // Minor methods:
@@ -189,72 +310,73 @@ void Solver::initNbInitialVars(int nb) {
 // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
 // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
 //
-Var Solver::newVar(bool sign, bool dvar)
-{
+
+Var Solver::newVar(bool sign, bool dvar) {
     int v = nVars();
-    watches  .init(mkLit(v, false));
-    watches  .init(mkLit(v, true ));
-    watchesBin  .init(mkLit(v, false));
-    watchesBin  .init(mkLit(v, true ));
-    assigns  .push(l_Undef);
-    vardata  .push(mkVarData(CRef_Undef, 0));
-    //activity .push(0);
+    watches .init(mkLit(v, false));
+    watches .init(mkLit(v, true));
+    watchesBin .init(mkLit(v, false));
+    watchesBin .init(mkLit(v, true));
+    unaryWatches .init(mkLit(v, false));
+    unaryWatches .init(mkLit(v, true));
+    assigns .push(l_Undef);
+    vardata .push(mkVarData(CRef_Undef, 0));
     activity .push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
-    seen     .push(0);
-    permDiff  .push(0);
+    seen .push(0);
+    permDiff .push(0);
     polarity .push(sign);
     decision .push();
-    trail    .capacity(v+1);
+    trail .capacity(v + 1);
     setDecisionVar(v, dvar);
     return v;
 }
 
+bool Solver::addClause_(vec<Lit>& ps) {
 
-
-bool Solver::addClause_(vec<Lit>& ps)
-{
     assert(decisionLevel() == 0);
     if (!ok) return false;
 
     // Check if clause is satisfied and remove false/duplicate literals:
     sort(ps);
 
-    vec<Lit>    oc;
+    vec<Lit> oc;
     oc.clear();
 
-    Lit p; int i, j, flag = 0;
-    if(certifiedUNSAT) {
-      for (i = j = 0, p = lit_Undef; i < ps.size(); i++) {
-        oc.push(ps[i]);
-        if (value(ps[i]) == l_True || ps[i] == ~p || value(ps[i]) == l_False)
-          flag = 1;
-      }
+    Lit p;
+    int i, j, flag = 0;
+    if (certifiedUNSAT) {
+        for (i = j = 0, p = lit_Undef; i < ps.size(); i++) {
+            oc.push(ps[i]);
+            if (value(ps[i]) == l_True || ps[i] == ~p || value(ps[i]) == l_False)
+                flag = 1;
+        }
     }
 
     for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
-      if (value(ps[i]) == l_True || ps[i] == ~p)
-	return true;
-      else if (value(ps[i]) != l_False && ps[i] != p)
-	ps[j++] = p = ps[i];
+        if (value(ps[i]) == l_True || ps[i] == ~p)
+            return true;
+        else if (value(ps[i]) != l_False && ps[i] != p)
+            ps[j++] = p = ps[i];
     ps.shrink(i - j);
-    
+
     if (flag && (certifiedUNSAT)) {
-      for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
-        fprintf(certifiedOutput, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
-      fprintf(certifiedOutput, "0\n");
-
-      fprintf(certifiedOutput, "d ");
-      for (i = j = 0, p = lit_Undef; i < oc.size(); i++)
-        fprintf(certifiedOutput, "%i ", (var(oc[i]) + 1) * (-2 * sign(oc[i]) + 1));
-      fprintf(certifiedOutput, "0\n");
+        for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
+            fprintf(certifiedOutput, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
+        fprintf(certifiedOutput, "0\n");
+
+        fprintf(certifiedOutput, "d ");
+        for (i = j = 0, p = lit_Undef; i < oc.size(); i++)
+            fprintf(certifiedOutput, "%i ", (var(oc[i]) + 1) * (-2 * sign(oc[i]) + 1));
+        fprintf(certifiedOutput, "0\n");
     }
 
+
     if (ps.size() == 0)
         return ok = false;
-    else if (ps.size() == 1){
+    else if (ps.size() == 1) {
         uncheckedEnqueue(ps[0]);
         return ok = (propagate() == CRef_Undef);
-    }else{
+    } else {
         CRef cr = ca.alloc(ps, false);
         clauses.push(cr);
         attachClause(cr);
@@ -263,79 +385,99 @@ bool Solver::addClause_(vec<Lit>& ps)
     return true;
 }
 
-
 void Solver::attachClause(CRef cr) {
     const Clause& c = ca[cr];
 
     assert(c.size() > 1);
-    if(c.size()==2) {
-      watchesBin[~c[0]].push(Watcher(cr, c[1]));
-      watchesBin[~c[1]].push(Watcher(cr, c[0]));
+    if (c.size() == 2) {
+        watchesBin[~c[0]].push(Watcher(cr, c[1]));
+        watchesBin[~c[1]].push(Watcher(cr, c[0]));
     } else {
-      watches[~c[0]].push(Watcher(cr, c[1]));
-      watches[~c[1]].push(Watcher(cr, c[0]));
+        watches[~c[0]].push(Watcher(cr, c[1]));
+        watches[~c[1]].push(Watcher(cr, c[0]));
     }
     if (c.learnt()) learnts_literals += c.size();
-    else            clauses_literals += c.size(); }
+    else clauses_literals += c.size();
+}
 
+void Solver::attachClausePurgatory(CRef cr) {
+    const Clause& c = ca[cr];
 
+    assert(c.size() > 1);
+    unaryWatches[~c[0]].push(Watcher(cr, c[1]));
 
+}
 
 void Solver::detachClause(CRef cr, bool strict) {
     const Clause& c = ca[cr];
-    
+
     assert(c.size() > 1);
-    if(c.size()==2) {
-      if (strict){
-        remove(watchesBin[~c[0]], Watcher(cr, c[1]));
-        remove(watchesBin[~c[1]], Watcher(cr, c[0]));
-      }else{
-        // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
-        watchesBin.smudge(~c[0]);
-        watchesBin.smudge(~c[1]);
-      }
+    if (c.size() == 2) {
+        if (strict) {
+            remove(watchesBin[~c[0]], Watcher(cr, c[1]));
+            remove(watchesBin[~c[1]], Watcher(cr, c[0]));
+        } else {
+            // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
+            watchesBin.smudge(~c[0]);
+            watchesBin.smudge(~c[1]);
+        }
     } else {
-      if (strict){
-        remove(watches[~c[0]], Watcher(cr, c[1]));
-        remove(watches[~c[1]], Watcher(cr, c[0]));
-      }else{
-        // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
-        watches.smudge(~c[0]);
-        watches.smudge(~c[1]);
-      }
+        if (strict) {
+            remove(watches[~c[0]], Watcher(cr, c[1]));
+            remove(watches[~c[1]], Watcher(cr, c[0]));
+        } else {
+            // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
+            watches.smudge(~c[0]);
+            watches.smudge(~c[1]);
+        }
     }
     if (c.learnt()) learnts_literals -= c.size();
-    else            clauses_literals -= c.size(); }
-
+    else clauses_literals -= c.size();
+}
 
-void Solver::removeClause(CRef cr) {
 
-  Clause& c = ca[cr];
+// The purgatory is the 1-Watched scheme for imported clauses
 
-  if (certifiedUNSAT) {
-    fprintf(certifiedOutput, "d ");
-    for (int i = 0; i < c.size(); i++)
-      fprintf(certifiedOutput, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
-    fprintf(certifiedOutput, "0\n");
-  }
+void Solver::detachClausePurgatory(CRef cr, bool strict) {
+    const Clause& c = ca[cr];
 
-  detachClause(cr);
-  // Don't leave pointers to free'd memory!
-  if (locked(c)) vardata[var(c[0])].reason = CRef_Undef;
-  c.mark(1);
-  ca.free(cr);
+    assert(c.size() > 1);
+    if (strict)
+        remove(unaryWatches[~c[0]], Watcher(cr, c[1]));
+    else
+        unaryWatches.smudge(~c[0]);
+}
+
+void Solver::removeClause(CRef cr, bool inPurgatory) {
+
+    Clause& c = ca[cr];
+
+    if (certifiedUNSAT) {
+        fprintf(certifiedOutput, "d ");
+        for (int i = 0; i < c.size(); i++)
+            fprintf(certifiedOutput, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
+        fprintf(certifiedOutput, "0\n");
+    }
+
+    if (inPurgatory)
+        detachClausePurgatory(cr);
+    else
+        detachClause(cr);
+    // Don't leave pointers to free'd memory!
+    if (locked(c)) vardata[var(c[0])].reason = CRef_Undef;
+    c.mark(1);
+    ca.free(cr);
 }
 
-
 bool Solver::satisfied(const Clause& c) const {
-  if(incremental)  // Check clauses with many selectors is too time consuming
-    return (value(c[0]) == l_True) || (value(c[1]) == l_True);
-
-  // Default mode.
+    if(incremental)     
+        return (value(c[0]) == l_True) || (value(c[1]) == l_True);
+    
+    // Default mode
     for (int i = 0; i < c.size(); i++)
         if (value(c[i]) == l_True)
             return true;
-    return false; 
+    return false;
 }
 
 /************************************************************
@@ -348,9 +490,9 @@ inline unsigned int Solver::computeLBD(c
 
   if(incremental) { // ----------------- INCREMENTAL MODE
     if(end==-1) end = lits.size();
-    unsigned int nbDone = 0;
+    int nbDone = 0;
     for(int i=0;i<lits.size();i++) {
-      if(nbDone>=static_cast<unsigned>(end)) break;
+      if(nbDone>=end) break;
       if(isSelector(var(lits[i]))) continue;
       nbDone++;
       int l = level(var(lits[i]));
@@ -369,7 +511,10 @@ inline unsigned int Solver::computeLBD(c
     }
   }
 
-  return nblevels;
+  if (!reduceOnSize)
+    return nblevels;
+  if (lits.size() < reduceOnSizeSize) return lits.size(); // See the XMinisat paper
+    return lits.size() + nblevels;
 }
 
 inline unsigned int Solver::computeLBD(const Clause &c) {
@@ -377,9 +522,9 @@ inline unsigned int Solver::computeLBD(c
   MYFLAG++;
 
   if(incremental) { // ----------------- INCREMENTAL MODE
-     int nbDone = 0;
+     unsigned int nbDone = 0;
     for(int i=0;i<c.size();i++) {
-      if(static_cast<unsigned>(nbDone)>=c.sizeWithoutSelectors()) break;
+      if(nbDone>=c.sizeWithoutSelectors()) break;
       if(isSelector(var(c[i]))) continue;
       nbDone++;
       int l = level(var(c[i]));
@@ -397,96 +542,103 @@ inline unsigned int Solver::computeLBD(c
       }
     }
   }
-  return nblevels;
-}
+  
+  if (!reduceOnSize)
+    return nblevels;
+  if (c.size() < reduceOnSizeSize) return c.size(); // See the XMinisat paper
+    return c.size() + nblevels;
 
+}
 
 /******************************************************************
  * Minimisation with binary reolution
  ******************************************************************/
 void Solver::minimisationWithBinaryResolution(vec<Lit> &out_learnt) {
-  
-  // Find the LBD measure                                                                                                         
-  unsigned int lbd = computeLBD(out_learnt);
-  Lit p = ~out_learnt[0];
-  
-  if(lbd<=lbLBDMinimizingClause){
-    MYFLAG++;
-    
-    for(int i = 1;i<out_learnt.size();i++) {
-      permDiff[var(out_learnt[i])] = MYFLAG;
-    }
 
-    vec<Watcher>&  wbin  = watchesBin[p];
-    int nb = 0;
-    for(int k = 0;k<wbin.size();k++) {
-      Lit imp = wbin[k].blocker;
-      if(permDiff[var(imp)]==MYFLAG && value(imp)==l_True) {
-	nb++;
-	permDiff[var(imp)]= MYFLAG-1;
-      }
-      }
-    int l = out_learnt.size()-1;
-    if(nb>0) {
-      nbReducedClauses++;
-      for(int i = 1;i<out_learnt.size()-nb;i++) {
-	if(permDiff[var(out_learnt[i])]!=MYFLAG) {
-	  Lit p = out_learnt[l];
-	  out_learnt[l] = out_learnt[i];
-	  out_learnt[i] = p;
-	  l--;i--;
-	}
-      }
-      
-      out_learnt.shrink(nb);
-      
+    // Find the LBD measure                                                                                                         
+    unsigned int lbd = computeLBD(out_learnt);
+    Lit p = ~out_learnt[0];
+
+    if (lbd <= lbLBDMinimizingClause) {
+        MYFLAG++;
+
+        for (int i = 1; i < out_learnt.size(); i++) {
+            permDiff[var(out_learnt[i])] = MYFLAG;
+        }
+
+        vec<Watcher>& wbin = watchesBin[p];
+        int nb = 0;
+        for (int k = 0; k < wbin.size(); k++) {
+            Lit imp = wbin[k].blocker;
+            if (permDiff[var(imp)] == MYFLAG && value(imp) == l_True) {
+                nb++;
+                permDiff[var(imp)] = MYFLAG - 1;
+            }
+        }
+        int l = out_learnt.size() - 1;
+        if (nb > 0) {
+            nbReducedClauses++;
+            for (int i = 1; i < out_learnt.size() - nb; i++) {
+                if (permDiff[var(out_learnt[i])] != MYFLAG) {
+                    Lit p = out_learnt[l];
+                    out_learnt[l] = out_learnt[i];
+                    out_learnt[i] = p;
+                    l--;
+                    i--;
+                }
+            }
+
+            out_learnt.shrink(nb);
+
+        }
     }
-  }
 }
 
 // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
 //
+
 void Solver::cancelUntil(int level) {
-    if (decisionLevel() > level){
-        for (int c = trail.size()-1; c >= trail_lim[level]; c--){
-            Var      x  = var(trail[c]);
+    if (decisionLevel() > level) {
+        for (int c = trail.size() - 1; c >= trail_lim[level]; c--) {
+            Var x = var(trail[c]);
             assigns [x] = l_Undef;
-	    if (phase_saving > 1 || ((phase_saving == 1) && c > trail_lim.last()))
+            if (phase_saving > 1 || ((phase_saving == 1) && c > trail_lim.last())) {
                 polarity[x] = sign(trail[c]);
-            insertVarOrder(x); }
+            }
+            insertVarOrder(x);
+        }
         qhead = trail_lim[level];
         trail.shrink(trail.size() - trail_lim[level]);
         trail_lim.shrink(trail_lim.size() - level);
-    } 
+    }
 }
 
 
 //=================================================================================================
 // Major methods:
 
-
-Lit Solver::pickBranchLit()
-{
+Lit Solver::pickBranchLit() {
     Var next = var_Undef;
 
     // Random decision:
-    if (drand(random_seed) < random_var_freq && !order_heap.empty()){
-        next = order_heap[irand(random_seed,order_heap.size())];
+    if (drand(random_seed) < random_var_freq && !order_heap.empty()) {
+        next = order_heap[irand(random_seed, order_heap.size())];
         if (value(next) == l_Undef && decision[next])
-            rnd_decisions++; }
+            rnd_decisions++;
+    }
 
     // Activity based decision:
     while (next == var_Undef || value(next) != l_Undef || !decision[next])
-        if (order_heap.empty()){
+        if (order_heap.empty()) {
             next = var_Undef;
             break;
-        }else
+        } else {
             next = order_heap.removeMin();
+        }
 
     return next == var_Undef ? lit_Undef : mkLit(next, rnd_pol ? drand(random_seed) < 0.5 : polarity[next]);
 }
 
-
 /*_________________________________________________________________________________________________
 |
 |  analyze : (confl : Clause*) (out_learnt : vec<Lit>&) (out_btlevel : int&)  ->  [void]
@@ -504,91 +656,94 @@ Lit Solver::pickBranchLit()
 |        rest of literals. There may be others from the same level though.
 |  
 |________________________________________________________________________________________________@*/
-void Solver::analyze(CRef confl, vec<Lit>& out_learnt,vec<Lit>&selectors, int& out_btlevel,unsigned int &lbd,unsigned int &szWithoutSelectors)
-{
+void Solver::analyze(CRef confl, vec<Lit>& out_learnt,vec<Lit>&selectors, int& out_btlevel,unsigned int &lbd,unsigned int &szWithoutSelectors) {
     int pathC = 0;
-    Lit p     = lit_Undef;
+    Lit p = lit_Undef;
+
 
     // Generate conflict clause:
     //
-    out_learnt.push();      // (leave room for the asserting literal)
-    int index   = trail.size() - 1;
-
-    do{
+    out_learnt.push(); // (leave room for the asserting literal)
+    int index = trail.size() - 1;
+    do {
         assert(confl != CRef_Undef); // (otherwise should be UIP)
         Clause& c = ca[confl];
+        // Special case for binary clauses
+        // The first one has to be SAT
+        if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
+
+            assert(value(c[1]) == l_True);
+            Lit tmp = c[0];
+            c[0] = c[1], c[1] = tmp;
+        }
 
-	// Special case for binary clauses
-	// The first one has to be SAT
-	if( p != lit_Undef && c.size()==2 && value(c[0])==l_False) {
-	  
-	  assert(value(c[1])==l_True);
-	  Lit tmp = c[0];
-	  c[0] =  c[1], c[1] = tmp;
-	}
-	
-	if (c.learnt()) 
+        if (c.learnt()) {
+            parallelImportClauseDuringConflictAnalysis(c,confl);
             claBumpActivity(c);
+         } else { // original clause
+            if (!c.getSeen()) {
+                originalClausesSeen++;
+                c.setSeen(true);
+            }
+        }
 
-#ifdef DYNAMICNBLEVEL		    
-	// DYNAMIC NBLEVEL trick (see competition'09 companion paper)
-	if(c.learnt()  && c.lbd()>2) { 
-	  unsigned int nblevels = computeLBD(c);
-	  if(nblevels+1<c.lbd() ) { // improve the LBD
-	    if(c.lbd()<=lbLBDFrozenClause) {
-	      c.setCanBeDel(false); 
-	    }
-	    // seems to be interesting : keep it for the next round
-	    c.setLBD(nblevels); // Update it
-	  }
-	}
-#endif
+        // DYNAMIC NBLEVEL trick (see competition'09 companion paper)
+        if (c.learnt() && c.lbd() > 2) {
+            unsigned int nblevels = computeLBD(c);
+            if (nblevels + 1 < c.lbd()) { // improve the LBD
+                if (c.lbd() <= lbLBDFrozenClause) {
+                    c.setCanBeDel(false);
+                }
+                // seems to be interesting : keep it for the next round
+                c.setLBD(nblevels); // Update it
+            }
+        }
 
 
-        for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
+        for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++) {
             Lit q = c[j];
 
-            if (!seen[var(q)] && level(var(q)) > 0){
-	      if(!isSelector(var(q)))
-                varBumpActivity(var(q));
-	      seen[var(q)] = 1;
-	      if (level(var(q)) >= decisionLevel()) {
-		pathC++;
-#ifdef UPDATEVARACTIVITY
-		// UPDATEVARACTIVITY trick (see competition'09 companion paper)
-		if(!isSelector(var(q)) && (reason(var(q))!= CRef_Undef)  && ca[reason(var(q))].learnt()) 
-		  lastDecisionLevel.push(q);
-#endif
-		
-	      } else {
-		if(isSelector(var(q))) {
-		  assert(value(q) == l_False);
-		  selectors.push(q);
-		} else 
-		  out_learnt.push(q);
-	      }
-	    }
+            if (!seen[var(q)]) {
+                if (level(var(q)) == 0) {
+                } else { // Here, the old case 
+                    if(!isSelector(var(q)))
+                        varBumpActivity(var(q));
+                    seen[var(q)] = 1;
+                    if (level(var(q)) >= decisionLevel()) {
+                        pathC++;
+                        // UPDATEVARACTIVITY trick (see competition'09 companion paper)
+                        if (!isSelector(var(q)) &&  (reason(var(q)) != CRef_Undef) && ca[reason(var(q))].learnt())
+                            lastDecisionLevel.push(q);
+                    } else {
+                        if(isSelector(var(q))) {
+                            assert(value(q) == l_False);
+                            selectors.push(q);
+                        } else 
+                            out_learnt.push(q);
+                   }
+                }
+            }
         }
-        
+
         // Select next clause to look at:
         while (!seen[var(trail[index--])]);
-        p     = trail[index+1];
+        p = trail[index + 1];
         confl = reason(var(p));
         seen[var(p)] = 0;
         pathC--;
 
-    }while (pathC > 0);
+    } while (pathC > 0);
     out_learnt[0] = ~p;
 
     // Simplify conflict clause:
     //
     int i, j;
 
-    for(int i = 0;i<selectors.size();i++)  
-      out_learnt.push(selectors[i]);       
+    for (int i = 0; i < selectors.size(); i++)
+        out_learnt.push(selectors[i]);
 
     out_learnt.copyTo(analyze_toclear);
-    if (ccmin_mode == 2){
+    if (ccmin_mode == 2) {
         uint32_t abstract_level = 0;
         for (i = 1; i < out_learnt.size(); i++)
             abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
@@ -596,23 +751,24 @@ void Solver::analyze(CRef confl, vec<Lit
         for (i = j = 1; i < out_learnt.size(); i++)
             if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
                 out_learnt[j++] = out_learnt[i];
-        
-    }else if (ccmin_mode == 1){
-        for (i = j = 1; i < out_learnt.size(); i++){
+
+    } else if (ccmin_mode == 1) {
+        for (i = j = 1; i < out_learnt.size(); i++) {
             Var x = var(out_learnt[i]);
 
             if (reason(x) == CRef_Undef)
                 out_learnt[j++] = out_learnt[i];
-            else{
+            else {
                 Clause& c = ca[reason(var(out_learnt[i]))];
                 // Thanks to Siert Wieringa for this bug fix!
-                for (int k = ((c.size()==2) ? 0:1); k < c.size(); k++)
-                    if (!seen[var(c[k])] && level(var(c[k])) > 0){
+                for (int k = ((c.size() == 2) ? 0 : 1); k < c.size(); k++)
+                    if (!seen[var(c[k])] && level(var(c[k])) > 0) {
                         out_learnt[j++] = out_learnt[i];
-                        break; }
+                        break;
+                    }
             }
         }
-    }else
+    } else
         i = j = out_learnt.size();
 
     max_literals += out_learnt.size();
@@ -626,29 +782,26 @@ void Solver::analyze(CRef confl, vec<Lit
       Then, we reduce clauses with small LBD.
       Otherwise, this can be useless
      */
-    if(!incremental && out_learnt.size()<=lbSizeMinimizingClause) {
-      minimisationWithBinaryResolution(out_learnt);
+    if (!incremental && out_learnt.size() <= lbSizeMinimizingClause) {
+        minimisationWithBinaryResolution(out_learnt);
     }
     // Find correct backtrack level:
     //
     if (out_learnt.size() == 1)
         out_btlevel = 0;
-    else{
+    else {
         int max_i = 1;
         // Find the first literal assigned at the next-highest level:
         for (int i = 2; i < out_learnt.size(); i++)
             if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))
                 max_i = i;
         // Swap-in this literal at index 1:
-        Lit p             = out_learnt[max_i];
+        Lit p = out_learnt[max_i];
         out_learnt[max_i] = out_learnt[1];
-        out_learnt[1]     = p;
-        out_btlevel       = level(var(p));
+        out_learnt[1] = p;
+        out_btlevel = level(var(p));
     }
-
-
-    // Compute the size of the clause without selectors (incremental mode)
-    if(incremental) {
+   if(incremental) {
       szWithoutSelectors = 0;
       for(int i=0;i<out_learnt.size();i++) {
 	if(!isSelector(var((out_learnt[i])))) szWithoutSelectors++; 
@@ -659,53 +812,54 @@ void Solver::analyze(CRef confl, vec<Lit
     
     // Compute LBD
     lbd = computeLBD(out_learnt,out_learnt.size()-selectors.size());
-
-  
-#ifdef UPDATEVARACTIVITY
-  // UPDATEVARACTIVITY trick (see competition'09 companion paper)
-  if(lastDecisionLevel.size()>0) {
-    for(int i = 0;i<lastDecisionLevel.size();i++) {
-      if(ca[reason(var(lastDecisionLevel[i]))].lbd()<lbd)
-	varBumpActivity(var(lastDecisionLevel[i]));
+     
+    // UPDATEVARACTIVITY trick (see competition'09 companion paper)
+    if (lastDecisionLevel.size() > 0) {
+        for (int i = 0; i < lastDecisionLevel.size(); i++) {
+            if (ca[reason(var(lastDecisionLevel[i]))].lbd() < lbd)
+                varBumpActivity(var(lastDecisionLevel[i]));
+        }
+        lastDecisionLevel.clear();
     }
-    lastDecisionLevel.clear();
-  } 
-#endif	    
 
 
 
-  for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
-  for(int j = 0 ; j<selectors.size() ; j++) seen[var(selectors[j])] = 0;  
+    for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0; // ('seen[]' is now cleared)
+    for (int j = 0; j < selectors.size(); j++) seen[var(selectors[j])] = 0;
 }
 
 
 // Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
 // visiting literals at levels that cannot be removed later.
-bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
-{
-    analyze_stack.clear(); analyze_stack.push(p);
+
+bool Solver::litRedundant(Lit p, uint32_t abstract_levels) {
+    analyze_stack.clear();
+    analyze_stack.push(p);
     int top = analyze_toclear.size();
-    while (analyze_stack.size() > 0){
+    while (analyze_stack.size() > 0) {
         assert(reason(var(analyze_stack.last())) != CRef_Undef);
-        Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
-	if(c.size()==2 && value(c[0])==l_False) {
-	  assert(value(c[1])==l_True);
-	  Lit tmp = c[0];
-	  c[0] =  c[1], c[1] = tmp;
-	}
-
-        for (int i = 1; i < c.size(); i++){
-            Lit p  = c[i];
-            if (!seen[var(p)] && level(var(p)) > 0){
-                if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
-                    seen[var(p)] = 1;
-                    analyze_stack.push(p);
-                    analyze_toclear.push(p);
-                }else{
-                    for (int j = top; j < analyze_toclear.size(); j++)
-                        seen[var(analyze_toclear[j])] = 0;
-                    analyze_toclear.shrink(analyze_toclear.size() - top);
-                    return false;
+        Clause& c = ca[reason(var(analyze_stack.last()))];
+        analyze_stack.pop(); // 
+        if (c.size() == 2 && value(c[0]) == l_False) {
+            assert(value(c[1]) == l_True);
+            Lit tmp = c[0];
+            c[0] = c[1], c[1] = tmp;
+        }
+
+        for (int i = 1; i < c.size(); i++) {
+            Lit p = c[i];
+            if (!seen[var(p)]) {
+                if (level(var(p)) > 0) {
+                    if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0) {
+                        seen[var(p)] = 1;
+                        analyze_stack.push(p);
+                        analyze_toclear.push(p);
+                    } else {
+                        for (int j = top; j < analyze_toclear.size(); j++)
+                            seen[var(analyze_toclear[j])] = 0;
+                        analyze_toclear.shrink(analyze_toclear.size() - top);
+                        return false;
+                    }
                 }
             }
         }
@@ -724,8 +878,7 @@ bool Solver::litRedundant(Lit p, uint32_
 |    Calculates the (possibly empty) set of assumptions that led to the assignment of 'p', and
 |    stores the result in 'out_conflict'.
 |________________________________________________________________________________________________@*/
-void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict)
-{
+void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict) {
     out_conflict.clear();
     out_conflict.push(p);
 
@@ -734,21 +887,21 @@ void Solver::analyzeFinal(Lit p, vec<Lit
 
     seen[var(p)] = 1;
 
-    for (int i = trail.size()-1; i >= trail_lim[0]; i--){
+    for (int i = trail.size() - 1; i >= trail_lim[0]; i--) {
         Var x = var(trail[i]);
-        if (seen[x]){
-            if (reason(x) == CRef_Undef){
+        if (seen[x]) {
+            if (reason(x) == CRef_Undef) {
                 assert(level(x) > 0);
                 out_conflict.push(~trail[i]);
-            }else{
+            } else {
                 Clause& c = ca[reason(x)];
-		//                for (int j = 1; j < c.size(); j++) Minisat (glucose 2.0) loop 
-		// Bug in case of assumptions due to special data structures for Binary.
-		// Many thanks to Sam Bayless (sbayless@cs.ubc.ca) for discover this bug.
-		for (int j = ((c.size()==2) ? 0:1); j < c.size(); j++)
+                //                for (int j = 1; j < c.size(); j++) Minisat (glucose 2.0) loop 
+                // Bug in case of assumptions due to special data structures for Binary.
+                // Many thanks to Sam Bayless (sbayless@cs.ubc.ca) for discover this bug.
+                for (int j = ((c.size() == 2) ? 0 : 1); j < c.size(); j++)
                     if (level(var(c[j])) > 0)
                         seen[var(c[j])] = 1;
-            }  
+            }
 
             seen[x] = 0;
         }
@@ -757,16 +910,13 @@ void Solver::analyzeFinal(Lit p, vec<Lit
     seen[var(p)] = 0;
 }
 
-
-void Solver::uncheckedEnqueue(Lit p, CRef from)
-{
+void Solver::uncheckedEnqueue(Lit p, CRef from) {
     assert(value(p) == l_Undef);
     assigns[var(p)] = lbool(!sign(p));
     vardata[var(p)] = mkVarData(from, decisionLevel());
     trail.push_(p);
 }
 
-
 /*_________________________________________________________________________________________________
 |
 |  propagate : [void]  ->  [Clause*]
@@ -778,60 +928,63 @@ void Solver::uncheckedEnqueue(Lit p, CRe
 |    Post-conditions:
 |      * the propagation queue is empty, even if there was a conflict.
 |________________________________________________________________________________________________@*/
-CRef Solver::propagate()
-{
-    CRef    confl     = CRef_Undef;
-    int     num_props = 0;
+CRef Solver::propagate() {
+    CRef confl = CRef_Undef;
+    int num_props = 0;
+//    int previousqhead = qhead;
     watches.cleanAll();
     watchesBin.cleanAll();
-    while (qhead < trail.size()){
-        Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
-        vec<Watcher>&  ws  = watches[p];
-        Watcher        *i, *j, *end;
+    unaryWatches.cleanAll();
+    while (qhead < trail.size()) {
+        Lit p = trail[qhead++]; // 'p' is enqueued fact to propagate.
+        vec<Watcher>& ws = watches[p];
+        Watcher *i, *j, *end;
         num_props++;
 
-	
-	    // First, Propagate binary clauses 
-	vec<Watcher>&  wbin  = watchesBin[p];
-	
-	for(int k = 0;k<wbin.size();k++) {
-	  
-	  Lit imp = wbin[k].blocker;
-	  
-	  if(value(imp) == l_False) {
-	    return wbin[k].cref;
-	  }
-	  
-	  if(value(imp) == l_Undef) {
-	    uncheckedEnqueue(imp,wbin[k].cref);
-	  }
-	}
-    
 
+        // First, Propagate binary clauses 
+        vec<Watcher>& wbin = watchesBin[p];
+
+        for (int k = 0; k < wbin.size(); k++) {
+
+            Lit imp = wbin[k].blocker;
 
-        for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
+            if (value(imp) == l_False) {
+                return wbin[k].cref;
+            }
+
+            if (value(imp) == l_Undef) {
+                uncheckedEnqueue(imp, wbin[k].cref);
+            }
+        }
+
+        // Now propagate other 2-watched clauses
+        for (i = j = (Watcher*) ws, end = i + ws.size(); i != end;) {
             // Try to avoid inspecting the clause:
             Lit blocker = i->blocker;
-            if (value(blocker) == l_True){
-                *j++ = *i++; continue; }
+            if (value(blocker) == l_True) {
+                *j++ = *i++;
+                continue;
+            }
 
             // Make sure the false literal is data[1]:
-            CRef     cr        = i->cref;
-            Clause&  c         = ca[cr];
-            Lit      false_lit = ~p;
+            CRef cr = i->cref;
+            Clause& c = ca[cr];
+            assert(!c.getOneWatched());
+            Lit false_lit = ~p;
             if (c[0] == false_lit)
                 c[0] = c[1], c[1] = false_lit;
             assert(c[1] == false_lit);
             i++;
 
             // If 0th watch is true, then clause is already satisfied.
-            Lit     first = c[0];
-            Watcher w     = Watcher(cr, first);
-            if (first != blocker && value(first) == l_True){
-	      
-	      *j++ = w; continue; }
+            Lit first = c[0];
+            Watcher w = Watcher(cr, first);
+            if (first != blocker && value(first) == l_True) {
 
-            // Look for new watch:
+                *j++ = w;
+                continue;
+            }
 	    if(incremental) { // ----------------- INCREMENTAL MODE
 	      int choosenPos = -1;
 	      for (int k = 2; k < c.size(); k++) {
@@ -863,30 +1016,125 @@ CRef Solver::propagate()
 		  goto NextClause; }
 	      }
 	    }
-
+            
             // Did not find watch -- clause is unit under assignment:
             *j++ = w;
-            if (value(first) == l_False){
+            if (value(first) == l_False) {
                 confl = cr;
                 qhead = trail.size();
                 // Copy the remaining watches:
                 while (i < end)
                     *j++ = *i++;
-            }else {
+            } else {
                 uncheckedEnqueue(first, cr);
-	  
-		
-	    }
-        NextClause:;
+
+
+            }
+NextClause:
+            ;
         }
         ws.shrink(i - j);
+
+       // unaryWatches "propagation"
+        if (useUnaryWatched &&  confl == CRef_Undef) {
+            confl = propagateUnaryWatches(p);
+
+        }
+ 
     }
+
+        
+
     propagations += num_props;
     simpDB_props -= num_props;
-    
+
     return confl;
 }
 
+/*_________________________________________________________________________________________________
+|
+|  propagateUnaryWatches : [Lit]  ->  [Clause*]
+|  
+|  Description:
+|    Propagates unary watches of Lit p, return a conflict 
+|    otherwise CRef_Undef
+|  
+|________________________________________________________________________________________________@*/
+
+CRef Solver::propagateUnaryWatches(Lit p) {
+    CRef confl= CRef_Undef;
+    Watcher *i, *j, *end;
+    vec<Watcher>& ws = unaryWatches[p];
+    for (i = j = (Watcher*) ws, end = i + ws.size(); i != end;) {
+        // Try to avoid inspecting the clause:
+        Lit blocker = i->blocker;
+        if (value(blocker) == l_True) {
+            *j++ = *i++;
+            continue;
+        }
+
+        // Make sure the false literal is data[1]:
+        CRef cr = i->cref;
+        Clause& c = ca[cr];
+        assert(c.getOneWatched());
+        Lit false_lit = ~p;
+        assert(c[0] == false_lit); // this is unary watch... No other choice if "propagated"
+        //if (c[0] == false_lit)
+        //c[0] = c[1], c[1] = false_lit;
+        //assert(c[1] == false_lit);
+        i++;
+        Watcher w = Watcher(cr, c[0]);
+        for (int k = 1; k < c.size(); k++) {
+            if (value(c[k]) != l_False) {
+                c[0] = c[k];
+                c[k] = false_lit;
+                unaryWatches[~c[0]].push(w);
+                goto NextClauseUnary;
+            }
+        }
+
+        // Did not find watch -- clause is empty under assignment:
+        *j++ = w;
+
+        confl = cr;
+        qhead = trail.size();
+        // Copy the remaining watches:
+        while (i < end)
+            *j++ = *i++;
+
+        // We can add it now to the set of clauses when backtracking
+        //printf("*");
+        if (promoteOneWatchedClause) {
+            nbPromoted++;
+            // Let's find the two biggest decision levels in the clause s.t. it will correctly be propagated when we'll backtrack
+            int maxlevel = -1;
+            int index = -1;
+            for (int k = 1; k < c.size(); k++) {
+                assert(value(c[k]) == l_False);
+                assert(level(var(c[k])) <= level(var(c[0])));
+                if (level(var(c[k])) > maxlevel) {
+                    index = k;
+                    maxlevel = level(var(c[k]));
+                }
+            }
+            detachClausePurgatory(cr, true); // TODO: check that the cleanAll is ok (use ",true" otherwise)
+            assert(index != -1);
+            Lit tmp = c[1];
+            c[1] = c[index], c[index] = tmp;
+            attachClause(cr);
+            // TODO used in function ParallelSolver::reportProgressArrayImports 
+            //Override :-(
+            //goodImportsFromThreads[ca[cr].importedFrom()]++;
+            ca[cr].setOneWatched(false);
+            ca[cr].setExported(2);  
+        }
+NextClauseUnary:
+        ;
+    }
+    ws.shrink(i - j);
+
+    return confl;
+}
 
 /*_________________________________________________________________________________________________
 |
@@ -896,29 +1144,7 @@ CRef Solver::propagate()
 |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
 |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
 |________________________________________________________________________________________________@*/
-struct reduceDB_lt { 
-    ClauseAllocator& ca;
-    reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
-    bool operator () (CRef x, CRef y) { 
- 
-    // Main criteria... Like in MiniSat we keep all binary clauses
-    if(ca[x].size()> 2 && ca[y].size()==2) return 1;
-    
-    if(ca[y].size()>2 && ca[x].size()==2) return 0;
-    if(ca[x].size()==2 && ca[y].size()==2) return 0;
-    
-    // Second one  based on literal block distance
-    if(ca[x].lbd()> ca[y].lbd()) return 1;
-    if(ca[x].lbd()< ca[y].lbd()) return 0;    
-    
-    
-    // Finally we can use old activity or size, we choose the last one
-        return ca[x].activity() < ca[y].activity();
-	//return x->size() < y->size();
-
-        //return ca[x].size() > 2 && (ca[y].size() == 2 || ca[x].activity() < ca[y].activity()); } 
-    }    
-};
+
 
 void Solver::reduceDB()
 {
@@ -955,32 +1181,32 @@ void Solver::reduceDB()
 }
 
 
-void Solver::removeSatisfied(vec<CRef>& cs)
-{
-  
+void Solver::removeSatisfied(vec<CRef>& cs) {
+
     int i, j;
-    for (i = j = 0; i < cs.size(); i++){
+    for (i = j = 0; i < cs.size(); i++) {
         Clause& c = ca[cs[i]];
 
 
-        if (satisfied(c)) 
-            removeClause(cs[i]);
+        if (satisfied(c))
+            if (c.getOneWatched())
+                removeClause(cs[i], true);
+            else
+                removeClause(cs[i]);
         else
             cs[j++] = cs[i];
     }
     cs.shrink(i - j);
 }
 
-
-void Solver::rebuildOrderHeap()
-{
+void Solver::rebuildOrderHeap() {
     vec<Var> vs;
     for (Var v = 0; v < nVars(); v++)
         if (decision[v] && value(v) == l_Undef)
             vs.push(v);
     order_heap.build(vs);
-}
 
+}
 
 /*_________________________________________________________________________________________________
 |
@@ -990,25 +1216,31 @@ void Solver::rebuildOrderHeap()
 |    Simplify the clause database according to the current top-level assigment. Currently, the only
 |    thing done here is the removal of satisfied clauses, but more things can be put here.
 |________________________________________________________________________________________________@*/
-bool Solver::simplify()
-{
+bool Solver::simplify() {
     assert(decisionLevel() == 0);
 
-    if (!ok || propagate() != CRef_Undef)
-        return ok = false;
+    if (!ok) return ok = false;
+    else {
+        CRef cr = propagate();
+        if (cr != CRef_Undef) {
+            return ok = false;
+        }
+    }
+
 
     if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
         return true;
 
     // Remove satisfied clauses:
     removeSatisfied(learnts);
-    if (remove_satisfied)        // Can be turned off.
+    removeSatisfied(unaryWatchedClauses);
+    if (remove_satisfied) // Can be turned off.
         removeSatisfied(clauses);
     checkGarbage();
     rebuildOrderHeap();
 
     simpDB_assigns = nAssigns();
-    simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
+    simpDB_props = clauses_literals + learnts_literals; // (shouldn't depend on stats really, but it will do for now)
 
     return true;
 }
@@ -1027,131 +1259,156 @@ bool Solver::simplify()
 |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
 |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
 |________________________________________________________________________________________________@*/
-lbool Solver::search(int )
-{
+lbool Solver::search(int) {
     assert(ok);
-    int         backtrack_level;
-    int         conflictC = 0;
-    vec<Lit>    learnt_clause,selectors;
-    unsigned int nblevels,szWoutSelectors;
-    bool blocked=false;
+    int backtrack_level;
+    int conflictC = 0;
+    vec<Lit> learnt_clause, selectors;
+    unsigned int nblevels,szWithoutSelectors = 0;
+    bool blocked = false;
     starts++;
-    for (;;){
+    for (;;) {
+        if (decisionLevel() == 0) { // We import clauses FIXME: ensure that we will import clauses enventually (restart after some point)
+            parallelImportUnaryClauses();
+            
+            if (parallelImportClauses())
+                return l_False;
+
+        }
         CRef confl = propagate();
-        if (confl != CRef_Undef){
+
+        if (confl != CRef_Undef) {
+            if(parallelJobIsFinished())
+                return l_Undef;
+            
+            
+            sumDecisionLevels += decisionLevel();
             // CONFLICT
-	  conflicts++; conflictC++;conflictsRestarts++;
-	  if(conflicts%5000==0 && var_decay<0.95)
-            var_decay += 0.01;
-
-	  if (verbosity >= 1 && conflicts%verbEveryConflicts==0){
-	    printf("c | %8d   %7d    %5d | %7d %8d %8d | %5d %8d   %6d %8d | %6.3f %% |\n", 
-		   (int)starts,(int)nbstopsrestarts, (int)(conflicts/starts), 
-		   (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals, 
-		   (int)nbReduceDB, nLearnts(), (int)nbDL2,(int)nbRemovedClauses, progressEstimate()*100);
-	  }
-	  if (decisionLevel() == 0) {
-	    return l_False;
-	    
-	  }
-	  
-	  trailQueue.push(trail.size());
-	  // BLOCK RESTART (CP 2012 paper)
-	  if( conflictsRestarts>LOWER_BOUND_FOR_BLOCKING_RESTART && lbdQueue.isvalid()  && trail.size()>R*trailQueue.getavg()) {
-	    lbdQueue.fastclear();
-	    nbstopsrestarts++;
-	    if(!blocked) {lastblockatrestart=starts;nbstopsrestartssame++;blocked=true;}
-	  }
+            conflicts++;
+            conflictC++;
+            conflictsRestarts++;
+           if (conflicts % 5000 == 0 && var_decay < max_var_decay)
+                var_decay += 0.01;
+
+            if (verbosity >= 1 && conflicts % verbEveryConflicts == 0) {
+                printf("c | %8d   %7d    %5d | %7d %8d %8d | %5d %8d   %6d %8d | %6.3f %% |\n",
+                        (int) starts, (int) nbstopsrestarts, (int) (conflicts / starts),
+                        (int) dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int) clauses_literals,
+                        (int) nbReduceDB, nLearnts(), (int) nbDL2, (int) nbRemovedClauses, progressEstimate()*100);
+            }
+            if (decisionLevel() == 0) {
+                return l_False;
+
+            }
+
+            trailQueue.push(trail.size());
+            // BLOCK RESTART (CP 2012 paper)
+            if (conflictsRestarts > LOWER_BOUND_FOR_BLOCKING_RESTART && lbdQueue.isvalid() && trail.size() > R * trailQueue.getavg()) {
+                lbdQueue.fastclear();
+                nbstopsrestarts++;
+                if (!blocked) {
+                    lastblockatrestart = starts;
+                    nbstopsrestartssame++;
+                    blocked = true;
+                }
+            }
 
             learnt_clause.clear();
-	    selectors.clear();
-            analyze(confl, learnt_clause, selectors,backtrack_level,nblevels,szWoutSelectors);
+            selectors.clear();
 
-	    lbdQueue.push(nblevels);
-	    sumLBD += nblevels;
- 
+            analyze(confl, learnt_clause, selectors, backtrack_level, nblevels,szWithoutSelectors);
+
+            lbdQueue.push(nblevels);
+            sumLBD += nblevels;
 
             cancelUntil(backtrack_level);
 
             if (certifiedUNSAT) {
-              for (int i = 0; i < learnt_clause.size(); i++)
-                fprintf(certifiedOutput, "%i " , (var(learnt_clause[i]) + 1) *
-                            (-2 * sign(learnt_clause[i]) + 1) );
-              fprintf(certifiedOutput, "0\n");
+                for (int i = 0; i < learnt_clause.size(); i++)
+                    fprintf(certifiedOutput, "%i ", (var(learnt_clause[i]) + 1) *
+                        (-2 * sign(learnt_clause[i]) + 1));
+                fprintf(certifiedOutput, "0\n");
             }
 
-            if (learnt_clause.size() == 1){
-	      uncheckedEnqueue(learnt_clause[0]);nbUn++;
-            }else{
+
+            if (learnt_clause.size() == 1) {
+                uncheckedEnqueue(learnt_clause[0]);
+                nbUn++;
+                parallelExportUnaryClause(learnt_clause[0]);
+            } else {
                 CRef cr = ca.alloc(learnt_clause, true);
-		ca[cr].setLBD(nblevels); 
-		ca[cr].setSizeWithoutSelectors(szWoutSelectors);
-		if(nblevels<=2) nbDL2++; // stats
-		if(ca[cr].size()==2) nbBin++; // stats
+                ca[cr].setLBD(nblevels);
+                ca[cr].setOneWatched(false);
+		ca[cr].setSizeWithoutSelectors(szWithoutSelectors);
+                if (nblevels <= 2) nbDL2++; // stats
+                if (ca[cr].size() == 2) nbBin++; // stats
                 learnts.push(cr);
                 attachClause(cr);
-
+                lastLearntClause = cr; // Use in multithread (to hard to put inside ParallelSolver)
+                parallelExportClauseDuringSearch(ca[cr]);
                 claBumpActivity(ca[cr]);
                 uncheckedEnqueue(learnt_clause[0], cr);
+
             }
             varDecayActivity();
             claDecayActivity();
 
-           
-        }else{
-	  // Our dynamic restart, see the SAT09 competition compagnion paper 
-	  if (
-	      ( lbdQueue.isvalid() && ((lbdQueue.getavg()*K) > (sumLBD / conflictsRestarts)))) {
-	    lbdQueue.fastclear();
-	    progress_estimate = progressEstimate();
-	    int bt = 0;
-	    if(incremental) { // DO NOT BACKTRACK UNTIL 0.. USELESS
-	      bt = (decisionLevel()<assumptions.size()) ? decisionLevel() : assumptions.size();
-	    }
-	    cancelUntil(bt);
-	    return l_Undef; }
 
+        } else {
+            // Our dynamic restart, see the SAT09 competition compagnion paper 
+            if (
+                    (lbdQueue.isvalid() && ((lbdQueue.getavg() * K) > (sumLBD / conflictsRestarts)))) {
+                lbdQueue.fastclear();
+                progress_estimate = progressEstimate();
+                int bt = 0;
+                if(incremental) // DO NOT BACKTRACK UNTIL 0.. USELESS
+                    bt = (decisionLevel()<assumptions.size()) ? decisionLevel() : assumptions.size();
+                cancelUntil(bt);
+                return l_Undef;
+            }
 
-           // Simplify the set of problem clauses:
-	  if (decisionLevel() == 0 && !simplify()) {
-	    return l_False;
-	  }
-	    // Perform clause database reduction !
-	    if(static_cast<unsigned>(conflicts)>=curRestart* nbclausesbeforereduce) 
-	      {
-	
-		assert(learnts.size()>0);
-		curRestart = (conflicts/ nbclausesbeforereduce)+1;
-		reduceDB();
-		nbclausesbeforereduce += incReduceDB;
-	      }
-	    
+
+            // Simplify the set of problem clauses:
+            if (decisionLevel() == 0 && !simplify()) {
+                return l_False;
+            }
+            // Perform clause database reduction !
+            if (conflicts >= ((unsigned int) curRestart * nbclausesbeforereduce)) {
+
+                if (learnts.size() > 0) {
+                    curRestart = (conflicts / nbclausesbeforereduce) + 1;
+                    reduceDB();
+                    if (!panicModeIsEnabled())
+                        nbclausesbeforereduce += incReduceDB;
+                }
+            }
+
+            lastLearntClause = CRef_Undef;
             Lit next = lit_Undef;
-            while (decisionLevel() < assumptions.size()){
+            while (decisionLevel() < assumptions.size()) {
                 // Perform user provided assumption:
                 Lit p = assumptions[decisionLevel()];
-                if (value(p) == l_True){
+                if (value(p) == l_True) {
                     // Dummy decision level:
                     newDecisionLevel();
-                }else if (value(p) == l_False){
+                } else if (value(p) == l_False) {
                     analyzeFinal(~p, conflict);
                     return l_False;
-                }else{
+                } else {
                     next = p;
                     break;
                 }
             }
 
-            if (next == lit_Undef){
+            if (next == lit_Undef) {
                 // New variable decision:
                 decisions++;
                 next = pickBranchLit();
-
-                if (next == lit_Undef){
-		  printf("c last restart ## conflicts  :  %d %d \n",conflictC,decisionLevel());
-		  // Model found:
-		  return l_True;
-		}
+                if (next == lit_Undef) {
+                    printf("c last restart ## conflicts  :  %d %d \n", conflictC, decisionLevel());
+                    // Model found:
+                    return l_True;
+                }
             }
 
             // Increase decision level and enqueue 'next'
@@ -1161,13 +1418,11 @@ lbool Solver::search(int )
     }
 }
 
+double Solver::progressEstimate() const {
+    double progress = 0;
+    double F = 1.0 / nVars();
 
-double Solver::progressEstimate() const
-{
-    double  progress = 0;
-    double  F = 1.0 / nVars();
-
-    for (int i = 0; i <= decisionLevel(); i++){
+    for (int i = 0; i <= decisionLevel(); i++) {
         int beg = i == 0 ? 0 : trail_lim[i - 1];
         int end = i == decisionLevel() ? trail.size() : trail_lim[i];
         progress += pow(F, i) * (end - beg);
@@ -1178,43 +1433,42 @@ double Solver::progressEstimate() const
 
 void Solver::printIncrementalStats() {
 
-//  printf("c---------- Glucose Stats -------------------------\n");
-//  printf("c restarts              : %lld\n", starts);
-//  printf("c nb ReduceDB           : %lld\n", nbReduceDB);
-//  printf("c nb removed Clauses    : %lld\n",nbRemovedClauses);
-//  printf("c nb learnts DL2        : %lld\n", nbDL2);
-//  printf("c nb learnts size 2     : %lld\n", nbBin);
-//  printf("c nb learnts size 1     : %lld\n", nbUn);
-//
-//  printf("c conflicts             : %lld \n",conflicts);
-//  printf("c decisions             : %lld\n",decisions);
-//  printf("c propagations          : %lld\n",propagations);
-//
-//  printf("c SAT Calls             : %d in %g seconds\n",nbSatCalls,totalTime4Sat);
-//  printf("c UNSAT Calls           : %d in %g seconds\n",nbUnsatCalls,totalTime4Unsat);
-//  printf("c--------------------------------------------------\n");
+    printf("c---------- Glucose Stats -------------------------\n");
+    printf("c restarts              : %" PRIu64"\n", starts);
+    printf("c nb ReduceDB           : %" PRIu64"\n", nbReduceDB);
+    printf("c nb removed Clauses    : %" PRIu64"\n", nbRemovedClauses);
+    printf("c nb learnts DL2        : %" PRIu64"\n", nbDL2);
+    printf("c nb learnts size 2     : %" PRIu64"\n", nbBin);
+    printf("c nb learnts size 1     : %" PRIu64"\n", nbUn);
+
+    printf("c conflicts             : %" PRIu64"\n", conflicts);
+    printf("c decisions             : %" PRIu64"\n", decisions);
+    printf("c propagations          : %" PRIu64"\n", propagations);
 
+  printf("\nc SAT Calls             : %d in %g seconds\n",nbSatCalls,totalTime4Sat);
+  printf("c UNSAT Calls           : %d in %g seconds\n",nbUnsatCalls,totalTime4Unsat);
 
+    printf("c--------------------------------------------------\n");
 }
 
-
 // NOTE: assumptions passed in member-variable 'assumptions'.
-lbool Solver::solve_()
+
+lbool Solver::solve_(bool, bool) // Parameters are useless in core but useful for SimpSolver....
 {
 
-  if(incremental && certifiedUNSAT) {
+    if(incremental && certifiedUNSAT) {
     printf("Can not use incremental and certified unsat in the same time\n");
     exit(-1);
   }
+ 
     model.clear();
     conflict.clear();
     if (!ok) return l_False;
     double curTime = cpuTime();
 
-    
     solves++;
             
-
+   
     
     lbool   status        = l_Undef;
     if(!incremental && verbosity>=1) {
@@ -1222,14 +1476,14 @@ lbool Solver::solve_()
       printf("c | Constants are supposed to work well together :-)                                                      |\n");
       printf("c | however, if you find better choices, please let us known...                                           |\n");
       printf("c |-------------------------------------------------------------------------------------------------------|\n");
-    printf("c |                                |                                |                                     |\n"); 
-    printf("c | - Restarts:                    | - Reduce Clause DB:            | - Minimize Asserting:               |\n");
-    printf("c |   * LBD Queue    : %6d      |   * First     : %6d         |    * size < %3d                     |\n",lbdQueue.maxSize(),nbclausesbeforereduce,lbSizeMinimizingClause);
-    printf("c |   * Trail  Queue : %6d      |   * Inc       : %6d         |    * lbd  < %3d                     |\n",trailQueue.maxSize(),incReduceDB,lbLBDMinimizingClause);
-    printf("c |   * K            : %6.2f      |   * Special   : %6d         |                                     |\n",K,specialIncReduceDB);
-    printf("c |   * R            : %6.2f      |   * Protected :  (lbd)< %2d     |                                     |\n",R,lbLBDFrozenClause);
-    printf("c |                                |                                |                                     |\n"); 
-printf("c ==================================[ Search Statistics (every %6d conflicts) ]=========================\n",verbEveryConflicts);
+      printf("c |                                |                                |                                     |\n"); 
+      printf("c | - Restarts:                    | - Reduce Clause DB:            | - Minimize Asserting:               |\n");
+      printf("c |   * LBD Queue    : %6d      |   * First     : %6d         |    * size < %3d                     |\n",lbdQueue.maxSize(),nbclausesbeforereduce,lbSizeMinimizingClause);
+      printf("c |   * Trail  Queue : %6d      |   * Inc       : %6d         |    * lbd  < %3d                     |\n",trailQueue.maxSize(),incReduceDB,lbLBDMinimizingClause);
+      printf("c |   * K            : %6.2f      |   * Special   : %6d         |                                     |\n",K,specialIncReduceDB);
+      printf("c |   * R            : %6.2f      |   * Protected :  (lbd)< %2d     |                                     |\n",R,lbLBDFrozenClause);
+      printf("c |                                |                                |                                     |\n"); 
+      printf("c ==================================[ Search Statistics (every %6d conflicts) ]=========================\n",verbEveryConflicts);
       printf("c |                                                                                                       |\n"); 
 
       printf("c |          RESTARTS           |          ORIGINAL         |              LEARNT              | Progress |\n");
@@ -1249,7 +1503,6 @@ printf("c ==============================
     if (!incremental && verbosity >= 1)
       printf("c =========================================================================================================\n");
 
-
     if (certifiedUNSAT){ // Want certified output
       if (status == l_False)
 	fprintf(certifiedOutput, "0\n");
@@ -1268,48 +1521,49 @@ printf("c ==============================
 
     cancelUntil(0);
 
+
     double finalTime = cpuTime();
     if(status==l_True) {
-      nbSatCalls++; 
-      totalTime4Sat +=(finalTime-curTime);
+        nbSatCalls++; 
+        totalTime4Sat +=(finalTime-curTime);
     }
     if(status==l_False) {
-      nbUnsatCalls++; 
-      totalTime4Unsat +=(finalTime-curTime);
+        nbUnsatCalls++; 
+        totalTime4Unsat +=(finalTime-curTime);
     }
-
+    
 
     return status;
+
 }
 
+
+
+
+
 //=================================================================================================
 // Writing CNF to DIMACS:
 // 
 // FIXME: this needs to be rewritten completely.
 
-static Var mapVar(Var x, vec<Var>& map, Var& max)
-{
-    if (map.size() <= x || map[x] == -1){
-        map.growTo(x+1, -1);
+static Var mapVar(Var x, vec<Var>& map, Var& max) {
+    if (map.size() <= x || map[x] == -1) {
+        map.growTo(x + 1, -1);
         map[x] = max++;
     }
     return map[x];
 }
 
-
-void Solver::toDimacs(FILE* f, Clause& c, vec<Var>& map, Var& max)
-{
+void Solver::toDimacs(FILE* f, Clause& c, vec<Var>& map, Var& max) {
     if (satisfied(c)) return;
 
     for (int i = 0; i < c.size(); i++)
         if (value(c[i]) != l_False)
-            fprintf(f, "%s%d ", sign(c[i]) ? "-" : "", mapVar(var(c[i]), map, max)+1);
+            fprintf(f, "%s%d ", sign(c[i]) ? "-" : "", mapVar(var(c[i]), map, max) + 1);
     fprintf(f, "0\n");
 }
 
-
-void Solver::toDimacs(const char *file, const vec<Lit>& assumps)
-{
+void Solver::toDimacs(const char *file, const vec<Lit>& assumps) {
     FILE* f = fopen(file, "wr");
     if (f == NULL)
         fprintf(stderr, "could not open file %s\n", file), exit(1);
@@ -1317,15 +1571,15 @@ void Solver::toDimacs(const char *file,
     fclose(f);
 }
 
-
-void Solver::toDimacs(FILE* f, const vec<Lit>& )
-{
+void Solver::toDimacs(FILE* f, const vec<Lit>&) {
     // Handle case when solver is in contradictory state:
-    if (!ok){
+    if (!ok) {
         fprintf(f, "p cnf 1 2\n1 0\n-1 0\n");
-        return; }
+        return;
+    }
 
-    vec<Var> map; Var max = 0;
+    vec<Var> map;
+    Var max = 0;
 
     // Cannot use removeClauses here because it is not safe
     // to deallocate them at this point. Could be improved.
@@ -1333,9 +1587,9 @@ void Solver::toDimacs(FILE* f, const vec
     for (int i = 0; i < clauses.size(); i++)
         if (!satisfied(ca[clauses[i]]))
             cnt++;
-        
+
     for (int i = 0; i < clauses.size(); i++)
-        if (!satisfied(ca[clauses[i]])){
+        if (!satisfied(ca[clauses[i]])) {
             Clause& c = ca[clauses[i]];
             for (int j = 0; j < c.size(); j++)
                 if (value(c[j]) != l_False)
@@ -1347,9 +1601,9 @@ void Solver::toDimacs(FILE* f, const vec
 
     fprintf(f, "p cnf %d %d\n", max, cnt);
 
-    for (int i = 0; i < assumptions.size(); i++){
+    for (int i = 0; i < assumptions.size(); i++) {
         assert(value(assumptions[i]) != l_False);
-        fprintf(f, "%s%d 0\n", sign(assumptions[i]) ? "-" : "", mapVar(var(assumptions[i]), map, max)+1);
+        fprintf(f, "%s%d 0\n", sign(assumptions[i]) ? "-" : "", mapVar(var(assumptions[i]), map, max) + 1);
     }
 
     for (int i = 0; i < clauses.size(); i++)
@@ -1363,15 +1617,15 @@ void Solver::toDimacs(FILE* f, const vec
 //=================================================================================================
 // Garbage Collection methods:
 
-void Solver::relocAll(ClauseAllocator& to)
-{
+void Solver::relocAll(ClauseAllocator& to) {
     // All watchers:
     //
     // for (int i = 0; i < watches.size(); i++)
     watches.cleanAll();
     watchesBin.cleanAll();
+    unaryWatches.cleanAll();
     for (int v = 0; v < nVars(); v++)
-        for (int s = 0; s < 2; s++){
+        for (int s = 0; s < 2; s++) {
             Lit p = mkLit(v, s);
             // printf(" >>> RELOCING: %s%d\n", sign(p)?"-":"", var(p)+1);
             vec<Watcher>& ws = watches[p];
@@ -1380,11 +1634,14 @@ void Solver::relocAll(ClauseAllocator& t
             vec<Watcher>& ws2 = watchesBin[p];
             for (int j = 0; j < ws2.size(); j++)
                 ca.reloc(ws2[j].cref, to);
+            vec<Watcher>& ws3 = unaryWatches[p];
+            for (int j = 0; j < ws3.size(); j++)
+                ca.reloc(ws3[j].cref, to);
         }
 
     // All reasons:
     //
-    for (int i = 0; i < trail.size(); i++){
+    for (int i = 0; i < trail.size(); i++) {
         Var v = var(trail[i]);
 
         if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))
@@ -1400,18 +1657,52 @@ void Solver::relocAll(ClauseAllocator& t
     //
     for (int i = 0; i < clauses.size(); i++)
         ca.reloc(clauses[i], to);
+
+    for (int i = 0; i < unaryWatchedClauses.size(); i++)
+        ca.reloc(unaryWatchedClauses[i], to);
 }
 
 
-void Solver::garbageCollect()
-{
+
+void Solver::garbageCollect() {
     // Initialize the next region to a size corresponding to the estimated utilization degree. This
     // is not precise but should avoid some unnecessary reallocations for the new region:
-    ClauseAllocator to(ca.size() - ca.wasted()); 
+    ClauseAllocator to(ca.size() - ca.wasted());
 
     relocAll(to);
     if (verbosity >= 2)
-        printf("|  Garbage collection:   %12d bytes => %12d bytes             |\n", 
-               ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
+        printf("|  Garbage collection:   %12d bytes => %12d bytes             |\n",
+            ca.size() * ClauseAllocator::Unit_Size, to.size() * ClauseAllocator::Unit_Size);
     to.moveTo(ca);
 }
+
+//--------------------------------------------------------------
+// Functions related to MultiThread.
+// Useless in case of single core solver (aka original glucose)
+// Keep them empty if you just use core solver
+//--------------------------------------------------------------
+
+bool Solver::panicModeIsEnabled() {
+    return false;
+}
+
+void Solver::parallelImportUnaryClauses() {
+}
+
+bool Solver::parallelImportClauses() {
+    return false;
+}
+
+
+void Solver::parallelExportUnaryClause(Lit) {
+}
+void Solver::parallelExportClauseDuringSearch(Clause &) {
+}
+
+bool Solver::parallelJobIsFinished() { 
+    // Parallel: another job has finished let's quit
+    return false;
+}
+
+void Solver::parallelImportClauseDuringConflictAnalysis(Clause &,CRef) {
+}
diff -rupN glucose-syrup/core/Solver.h glucose-syrup.modified/core/Solver.h
--- glucose-syrup/core/Solver.h	2014-11-24 15:54:11.967436464 +0100
+++ glucose-syrup.modified/core/Solver.h	2014-10-03 11:10:21.000000000 +0200
@@ -1,12 +1,33 @@
-/****************************************************************************************[Solver.h]
- Glucose -- Copyright (c) 2009, Gilles Audemard, Laurent Simon
-				CRIL - Univ. Artois, France
-				LRI  - Univ. Paris Sud, France
- 
+/***************************************************************************************[Solver.h]
+ Glucose -- Copyright (c) 2009-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                LRI  - Univ. Paris Sud, France (2009-2013)
+                                Labri - Univ. Bordeaux, France
+
+ Syrup (Glucose Parallel) -- Copyright (c) 2013-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                Labri - Univ. Bordeaux, France
+
 Glucose sources are based on MiniSat (see below MiniSat copyrights). Permissions and copyrights of
-Glucose are exactly the same as Minisat on which it is based on. (see below).
+Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it 
+is based on. (see below).
+
+Glucose-Syrup sources are based on another copyright. Permissions and copyrights for the parallel
+version of Glucose-Syrup (the "Software") are granted, free of charge, to deal with the Software
+without restriction, including the rights to use, copy, modify, merge, publish, distribute,
+sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is 
+furnished to do so, subject to the following conditions:
+
+- The above and below copyrights notices and this permission notice shall be included in all
+copies or substantial portions of the Software;
+- The parallel version of Glucose (all files modified since Glucose 3.0 releases, 2013) cannot
+be used in any competitive event (sat competitions/evaluations) without the express permission of 
+the authors (Gilles Audemard / Laurent Simon). This is also the case for any competitive event
+using Glucose Parallel as an embedded SAT engine (single core or not).
+
+
+--------------- Original Minisat Copyrights
 
----------------
 Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
 Copyright (c) 2007-2010, Niklas Sorensson
 
@@ -24,18 +45,18 @@ NOT LIMITED TO THE WARRANTIES OF MERCHAN
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-**************************************************************************************************/
+ **************************************************************************************************/
 
 #ifndef Glucose_Solver_h
 #define Glucose_Solver_h
 
-#include "mtl/Vec.h"
 #include "mtl/Heap.h"
 #include "mtl/Alg.h"
 #include "utils/Options.h"
 #include "core/SolverTypes.h"
 #include "core/BoundedQueue.h"
 #include "core/Constants.h"
+#include "mtl/Clone.h"
 
 
 namespace Glucose {
@@ -43,24 +64,35 @@ namespace Glucose {
 //=================================================================================================
 // Solver -- the main class:
 
-class Solver {
+class Solver : public Clone {
+
+    friend class SolverConfiguration;
+
 public:
 
     // Constructor/Destructor:
     //
     Solver();
+    Solver(const  Solver &s);
+    
     virtual ~Solver();
+    
+    /**
+     * Clone function
+     */
+    virtual Clone* clone() const {
+        return  new Solver(*this);
+    }   
 
     // Problem specification:
     //
-    Var     newVar    (bool polarity = true, bool dvar = true); // Add a new variable with parameters specifying variable mode.
-
+    virtual Var     newVar    (bool polarity = true, bool dvar = true); // Add a new variable with parameters specifying variable mode.
     bool    addClause (const vec<Lit>& ps);                     // Add a clause to the solver. 
     bool    addEmptyClause();                                   // Add the empty clause, making the solver contradictory.
     bool    addClause (Lit p);                                  // Add a unit clause to the solver. 
     bool    addClause (Lit p, Lit q);                           // Add a binary clause to the solver. 
     bool    addClause (Lit p, Lit q, Lit r);                    // Add a ternary clause to the solver. 
-    bool    addClause_(      vec<Lit>& ps);                     // Add a clause to the solver without making superflous internal copy. Will
+    virtual bool    addClause_(      vec<Lit>& ps);                     // Add a clause to the solver without making superflous internal copy. Will
                                                                 // change the passed vector 'ps'.
 
     // Solving:
@@ -74,17 +106,19 @@ public:
     bool    solve        (Lit p, Lit q, Lit r);     // Search for a model that respects three assumptions.
     bool    okay         () const;                  // FALSE means solver is in a conflicting state
 
+       // Convenience versions of 'toDimacs()':
     void    toDimacs     (FILE* f, const vec<Lit>& assumps);            // Write CNF to file in DIMACS-format.
     void    toDimacs     (const char *file, const vec<Lit>& assumps);
     void    toDimacs     (FILE* f, Clause& c, vec<Var>& map, Var& max);
-    void printLit(Lit l);
-    void printClause(CRef c);
-    void printInitialClause(CRef c);
-    // Convenience versions of 'toDimacs()':
     void    toDimacs     (const char* file);
     void    toDimacs     (const char* file, Lit p);
     void    toDimacs     (const char* file, Lit p, Lit q);
     void    toDimacs     (const char* file, Lit p, Lit q, Lit r);
+ 
+    // Display clauses and literals
+    void printLit(Lit l);
+    void printClause(CRef c);
+    void printInitialClause(CRef c);
     
     // Variable mode:
     // 
@@ -103,11 +137,13 @@ public:
     int     nVars      ()      const;       // The current number of variables.
     int     nFreeVars  ()      const;
 
+    inline char valuePhase(Var v) {return polarity[v];}
+
     // Incremental mode
     void setIncrementalMode();
     void initNbInitialVars(int nb);
     void printIncrementalStats();
-
+    bool isIncremental();
     // Resource contraints:
     //
     void    setConfBudget(int64_t x);
@@ -122,9 +158,6 @@ public:
     void    checkGarbage(double gf);
     void    checkGarbage();
 
-
-
-
     // Extra results: (read-only member variable)
     //
     vec<lbool> model;             // If problem is satisfiable, this vector contains the model (if any).
@@ -136,6 +169,7 @@ public:
     int       verbosity;
     int       verbEveryConflicts;
     int       showModel;
+    
     // Constants For restarts
     double    K;
     double    R;
@@ -143,16 +177,18 @@ public:
     double    sizeTrailQueue;
 
     // Constants for reduce DB
-    int firstReduceDB;
-    int incReduceDB;
-    int specialIncReduceDB;
+    int          firstReduceDB;
+    int          incReduceDB;
+    int          specialIncReduceDB;
     unsigned int lbLBDFrozenClause;
 
     // Constant for reducing clause
-    int lbSizeMinimizingClause;
+    int          lbSizeMinimizingClause;
     unsigned int lbLBDMinimizingClause;
 
+    // Constant for heuristic
     double    var_decay;
+    double    max_var_decay;
     double    clause_decay;
     double    random_var_freq;
     double    random_seed;
@@ -160,19 +196,44 @@ public:
     int       phase_saving;       // Controls the level of phase saving (0=none, 1=limited, 2=full).
     bool      rnd_pol;            // Use random polarities for branching heuristics.
     bool      rnd_init_act;       // Initialize variable activities with a small random value.
+    
+    // Constant for Memory managment
     double    garbage_frac;       // The fraction of wasted memory allowed before a garbage collection is triggered.
 
     // Certified UNSAT ( Thanks to Marijn Heule)
     FILE*               certifiedOutput;
     bool                certifiedUNSAT;
 
+    // Panic mode. 
+    // Save memory
+    uint32_t panicModeLastRemoved, panicModeLastRemovedShared;
+    
+    bool useUnaryWatched;            // Enable unary watched literals
+    bool promoteOneWatchedClause;    // One watched clauses are promotted to two watched clauses if found empty
     
+    // Functions useful for multithread solving
+    // Useless in the sequential case 
+    // Overide in ParallelSolver
+    virtual void parallelImportClauseDuringConflictAnalysis(Clause &c,CRef confl);
+    virtual bool parallelImportClauses(); // true if the empty clause was received
+    virtual void parallelImportUnaryClauses();
+    virtual void parallelExportUnaryClause(Lit p);
+    virtual void parallelExportClauseDuringSearch(Clause &c);
+    virtual bool parallelJobIsFinished();
+    virtual bool panicModeIsEnabled();
+    
+    
+
     // Statistics: (read-only member variable)
+    uint64_t    nbPromoted;          // Number of clauses from unary to binary watch scheme
+    uint64_t    originalClausesSeen; // Number of original clauses seen
+    uint64_t    sumDecisionLevels;
     //
-    uint64_t nbRemovedClauses,nbReducedClauses,nbDL2,nbBin,nbUn,nbReduceDB,solves, starts, decisions, rnd_decisions, propagations, conflicts,conflictsRestarts,nbstopsrestarts,nbstopsrestartssame,lastblockatrestart;
+    uint64_t nbRemovedClauses,nbRemovedUnaryWatchedClauses, nbReducedClauses,nbDL2,nbBin,nbUn,nbReduceDB,solves, starts, decisions, rnd_decisions, propagations, conflicts,conflictsRestarts,nbstopsrestarts,nbstopsrestartssame,lastblockatrestart;
     uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;
 
 protected:
+
     long curRestart;
     // Helper structures:
     //
@@ -185,6 +246,12 @@ protected:
         Watcher(CRef cr, Lit p) : cref(cr), blocker(p) {}
         bool operator==(const Watcher& w) const { return cref == w.cref; }
         bool operator!=(const Watcher& w) const { return cref != w.cref; }
+/*        Watcher &operator=(Watcher w) {
+            this->cref = w.cref;
+            this->blocker = w.blocker;
+            return *this;
+        }
+*/
     };
 
     struct WatcherDeleted
@@ -203,7 +270,7 @@ protected:
 
     // Solver state:
     //
-    int lastIndexRed;
+    int                lastIndexRed;
     bool                ok;               // If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!
     double              cla_inc;          // Amount to bump next clause with.
     vec<double>         activity;         // A heuristic measurement of the activity of a variable.
@@ -212,14 +279,17 @@ protected:
                         watches;          // 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).
     OccLists<Lit, vec<Watcher>, WatcherDeleted>
                         watchesBin;          // 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).
+    OccLists<Lit, vec<Watcher>, WatcherDeleted>
+                        unaryWatches;       //  Unary watch scheme (clauses are seen when they become empty
     vec<CRef>           clauses;          // List of problem clauses.
     vec<CRef>           learnts;          // List of learnt clauses.
+    vec<CRef>           unaryWatchedClauses;  // List of imported clauses (after the purgatory) // TODO put inside ParallelSolver
 
     vec<lbool>          assigns;          // The current assignments.
     vec<char>           polarity;         // The preferred polarity of each variable.
     vec<char>           decision;         // Declares if a variable is eligible for selection in the decision heuristic.
     vec<Lit>            trail;            // Assignment stack; stores all assigments made in the order they were made.
-        vec<int>            nbpos;
+    vec<int>            nbpos;
     vec<int>            trail_lim;        // Separator indices for different decision levels in 'trail'.
     vec<VarData>        vardata;          // Stores reason and level for each variable.
     int                 qhead;            // Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).
@@ -229,20 +299,23 @@ protected:
     Heap<VarOrderLt>    order_heap;       // A priority queue of variables ordered with respect to the variable activity.
     double              progress_estimate;// Set by 'search()'.
     bool                remove_satisfied; // Indicates whether possibly inefficient linear scan for satisfied clauses should be performed in 'simplify'.
-    vec<unsigned int> permDiff;      // permDiff[var] contains the current conflict number... Used to count the number of  LBD
+    bool reduceOnSize;
+    int  reduceOnSizeSize;                // See XMinisat paper
+    vec<unsigned int>   permDiff;           // permDiff[var] contains the current conflict number... Used to count the number of  LBD
     
-#ifdef UPDATEVARACTIVITY
+
     // UPDATEVARACTIVITY trick (see competition'09 companion paper)
     vec<Lit> lastDecisionLevel; 
-#endif
 
     ClauseAllocator     ca;
 
     int nbclausesbeforereduce;            // To know when it is time to reduce clause database
     
+    // Used for restart strategies
     bqueue<unsigned int> trailQueue,lbdQueue; // Bounded queues for restarts.
     float sumLBD; // used to compute the global average of LBD. Restarts...
     int sumAssumptions;
+    CRef lastLearntClause;
 
 
     // Temporaries (to reduce allocation overhead). Each variable is prefixed by the method in which it is
@@ -254,7 +327,7 @@ protected:
     vec<Lit>            add_tmp;
     unsigned int  MYFLAG;
 
-
+    // Initial reduceDB strategy
     double              max_learnts;
     double              learntsize_adjust_confl;
     int                 learntsize_adjust_cnt;
@@ -265,7 +338,6 @@ protected:
     int64_t             propagation_budget; // -1 means no budget.
     bool                asynch_interrupt;
 
-
     // Variables added for incremental mode
     int incremental; // Use incremental SAT Solver
     int nbVarsInitialFormula; // nb VAR in formula without assumptions (incremental SAT)
@@ -282,13 +354,14 @@ protected:
     void     uncheckedEnqueue (Lit p, CRef from = CRef_Undef);                         // Enqueue a literal. Assumes value of literal is undefined.
     bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
     CRef     propagate        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
+    CRef     propagateUnaryWatches(Lit p);                                                  // Perform propagation on unary watches of p, can find only conflicts
     void     cancelUntil      (int level);                                             // Backtrack until a certain level.
     void     analyze          (CRef confl, vec<Lit>& out_learnt, vec<Lit> & selectors, int& out_btlevel,unsigned int &nblevels,unsigned int &szWithoutSelectors);    // (bt = backtrack)
     void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
     bool     litRedundant     (Lit p, uint32_t abstract_levels);                       // (helper method for 'analyze()')
     lbool    search           (int nof_conflicts);                                     // Search for a given number of conflicts.
-    lbool    solve_           ();                                                      // Main solve method (assumptions given in 'assumptions').
-    void     reduceDB         ();                                                      // Reduce the set of learnt clauses.
+    virtual lbool    solve_           (bool do_simp = true, bool turn_off_simp = false);                                                      // Main solve method (assumptions given in 'assumptions').
+    virtual void     reduceDB         ();                                                      // Reduce the set of learnt clauses.
     void     removeSatisfied  (vec<CRef>& cs);                                         // Shrink 'cs' to contain only non-satisfied clauses.
     void     rebuildOrderHeap ();
 
@@ -304,7 +377,9 @@ protected:
     //
     void     attachClause     (CRef cr);               // Attach a clause to watcher lists.
     void     detachClause     (CRef cr, bool strict = false); // Detach a clause to watcher lists.
-    void     removeClause     (CRef cr);               // Detach and free a clause.
+    void     detachClausePurgatory(CRef cr, bool strict = false);
+    void     attachClausePurgatory(CRef cr);
+    void     removeClause     (CRef cr, bool inPurgatory = false);               // Detach and free a clause.
     bool     locked           (const Clause& c) const; // Returns TRUE if a clause is a reason for some implication in the current state.
     bool     satisfied        (const Clause& c) const; // Returns TRUE if a clause is satisfied in the current state.
 
@@ -312,7 +387,7 @@ protected:
     unsigned int computeLBD(const Clause &c);
     void minimisationWithBinaryResolution(vec<Lit> &out_learnt);
 
-    void     relocAll         (ClauseAllocator& to);
+    virtual void     relocAll         (ClauseAllocator& to);
 
     // Misc:
     //
@@ -439,6 +514,7 @@ inline void     Solver::toDimacs     (co
 inline void     Solver::toDimacs     (const char* file, Lit p, Lit q, Lit r){ vec<Lit> as; as.push(p); as.push(q); as.push(r); toDimacs(file, as); }
 
 
+
 //=================================================================================================
 // Debug etc:
 
@@ -469,8 +545,37 @@ inline void Solver::printInitialClause(C
     }
 }
 
-
 //=================================================================================================
+
+struct reduceDB_lt {
+    ClauseAllocator& ca;
+
+    reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {
+    }
+
+    bool operator()(CRef x, CRef y) {
+
+        // Main criteria... Like in MiniSat we keep all binary clauses
+        if (ca[x].size() > 2 && ca[y].size() == 2) return 1;
+
+        if (ca[y].size() > 2 && ca[x].size() == 2) return 0;
+        if (ca[x].size() == 2 && ca[y].size() == 2) return 0;
+
+        // Second one  based on literal block distance
+        if (ca[x].lbd() > ca[y].lbd()) return 1;
+        if (ca[x].lbd() < ca[y].lbd()) return 0;
+
+
+        // Finally we can use old activity or size, we choose the last one
+        return ca[x].activity() < ca[y].activity();
+        //return x->size() < y->size();
+
+        //return ca[x].size() > 2 && (ca[y].size() == 2 || ca[x].activity() < ca[y].activity()); } 
+    }
+};
+
+
 }
 
+
 #endif
diff -rupN glucose-syrup/core/SolverTypes.h glucose-syrup.modified/core/SolverTypes.h
--- glucose-syrup/core/SolverTypes.h	2014-11-24 15:54:11.967436464 +0100
+++ glucose-syrup.modified/core/SolverTypes.h	2014-10-03 11:10:22.000000000 +0200
@@ -1,12 +1,33 @@
-/***********************************************************************************[SolverTypes.h]
- Glucose -- Copyright (c) 2009, Gilles Audemard, Laurent Simon
-				CRIL - Univ. Artois, France
-				LRI  - Univ. Paris Sud, France
- 
+/***************************************************************************************[SolverTypes.h]
+ Glucose -- Copyright (c) 2009-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                LRI  - Univ. Paris Sud, France (2009-2013)
+                                Labri - Univ. Bordeaux, France
+
+ Syrup (Glucose Parallel) -- Copyright (c) 2013-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                Labri - Univ. Bordeaux, France
+
 Glucose sources are based on MiniSat (see below MiniSat copyrights). Permissions and copyrights of
-Glucose are exactly the same as Minisat on which it is based on. (see below).
+Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it 
+is based on. (see below).
+
+Glucose-Syrup sources are based on another copyright. Permissions and copyrights for the parallel
+version of Glucose-Syrup (the "Software") are granted, free of charge, to deal with the Software
+without restriction, including the rights to use, copy, modify, merge, publish, distribute,
+sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is 
+furnished to do so, subject to the following conditions:
+
+- The above and below copyrights notices and this permission notice shall be included in all
+copies or substantial portions of the Software;
+- The parallel version of Glucose (all files modified since Glucose 3.0 releases, 2013) cannot
+be used in any competitive event (sat competitions/evaluations) without the express permission of 
+the authors (Gilles Audemard / Laurent Simon). This is also the case for any competitive event
+using Glucose Parallel as an embedded SAT engine (single core or not).
+
+
+--------------- Original Minisat Copyrights
 
----------------
 Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
 Copyright (c) 2007-2010, Niklas Sorensson
 
@@ -24,13 +45,15 @@ NOT LIMITED TO THE WARRANTIES OF MERCHAN
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-**************************************************************************************************/
+ **************************************************************************************************/
 
 
 #ifndef Glucose_SolverTypes_h
 #define Glucose_SolverTypes_h
 
 #include <assert.h>
+#include <stdint.h>
+#include <pthread.h>
 
 #include "mtl/IntTypes.h"
 #include "mtl/Alg.h"
@@ -38,6 +61,7 @@ OF OR IN CONNECTION WITH THE SOFTWARE OR
 #include "mtl/Map.h"
 #include "mtl/Alloc.h"
 
+
 namespace Glucose {
 
 //=================================================================================================
@@ -55,7 +79,7 @@ struct Lit {
     int     x;
 
     // Use this as a constructor:
-    friend Lit mkLit(Var var, bool sign = false);
+    friend Lit mkLit(Var var, bool sign);
 
     bool operator == (Lit p) const { return x == p.x; }
     bool operator != (Lit p) const { return x != p.x; }
@@ -63,7 +87,7 @@ struct Lit {
 };
 
 
-inline  Lit  mkLit     (Var var, bool sign) { Lit p; p.x = var + var + (int)sign; return p; }
+inline  Lit  mkLit     (Var var, bool sign = false) { Lit p; p.x = var + var + (int)sign; return p; }
 inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
 inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
 inline  bool sign      (Lit p)              { return p.x & 1; }
@@ -128,56 +152,76 @@ inline lbool toLbool(int   v) { return l
 class Clause;
 typedef RegionAllocator<uint32_t>::Ref CRef;
 
+#define BITS_LBD 13
+#define BITS_SIZEWITHOUTSEL 19
+#define BITS_REALSIZE 21
 class Clause {
     struct {
-      unsigned mark      : 2;
-      unsigned learnt    : 1;
-      unsigned has_extra : 1;
-      unsigned reloced   : 1;
-      unsigned lbd       : 26;
-      unsigned canbedel  : 1;
-      unsigned size      : 32;
-      unsigned szWithoutSelectors : 32;
+      unsigned mark       : 2;
+      unsigned learnt     : 1;
+      unsigned szWithoutSelectors : BITS_SIZEWITHOUTSEL;
+      unsigned canbedel   : 1;
+      unsigned extra_size : 2; // extra size (end of 32bits) 0..3       
+      unsigned size       : BITS_REALSIZE;
+      unsigned seen       : 1;
+      unsigned reloced    : 1;
+      unsigned exported   : 2; // Values to keep track of the clause status for exportations
+      unsigned oneWatched : 1;
+      unsigned lbd : BITS_LBD;
+    }  header;
 
-    }                            header;
     union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];
 
     friend class ClauseAllocator;
 
     // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
     template<class V>
-    Clause(const V& ps, bool use_extra, bool learnt) {
+    Clause(const V& ps, int _extra_size, bool learnt) {
+	assert(_extra_size < (1<<2));
         header.mark      = 0;
         header.learnt    = learnt;
-        header.has_extra = use_extra;
+        header.extra_size = _extra_size;
         header.reloced   = 0;
         header.size      = ps.size();
 	header.lbd = 0;
 	header.canbedel = 1;
+	header.exported = 0; 
+	header.oneWatched = 0;
+	header.seen = 0;
         for (int i = 0; i < ps.size(); i++) 
             data[i].lit = ps[i];
 	
-        if (header.has_extra){
+        if (header.extra_size > 0){
 	  if (header.learnt) 
                 data[header.size].act = 0; 
             else 
-                calcAbstraction(); }
+                calcAbstraction();
+	  if (header.extra_size > 1) {
+	      data[header.size+1].abs = 0; // learntFrom
+	  }	      
+	}
     }
 
 public:
     void calcAbstraction() {
-        assert(header.has_extra);
+        assert(header.extra_size > 0);
         uint32_t abstraction = 0;
         for (int i = 0; i < size(); i++)
             abstraction |= 1 << (var(data[i].lit) & 31);
         data[header.size].abs = abstraction;  }
 
-
     int          size        ()      const   { return header.size; }
-    void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
+    void         shrink      (int i)         { assert(i <= size()); 
+						if (header.extra_size > 0) {
+						    data[header.size-i] = data[header.size];
+						    if (header.extra_size > 1) { // Special case for imported clauses
+							data[header.size-i-1] = data[header.size-1];
+						    }
+						}
+    header.size -= i; }
     void         pop         ()              { shrink(1); }
     bool         learnt      ()      const   { return header.learnt; }
-    bool         has_extra   ()      const   { return header.has_extra; }
+    bool         has_extra   ()      const   { return header.extra_size > 0; }
     uint32_t     mark        ()      const   { return header.mark; }
     void         mark        (uint32_t m)    { header.mark = m; }
     const Lit&   last        ()      const   { return data[header.size-1].lit; }
@@ -192,16 +236,27 @@ public:
     Lit          operator [] (int i) const   { return data[i].lit; }
     operator const Lit* (void) const         { return (Lit*)data; }
 
-    float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
-    uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }
+    float&       activity    ()              { assert(header.extra_size > 0); return data[header.size].act; }
+    uint32_t     abstraction () const        { assert(header.extra_size > 0); return data[header.size].abs; }
+
+    // Handle imported clauses lazy sharing
+    bool        wasImported() const {return header.extra_size > 1;}
+    uint32_t    importedFrom () const       { assert(header.extra_size > 1); return data[header.size + 1].abs;}
+    void setImportedFrom(uint32_t ifrom) {assert(header.extra_size > 1); data[header.size+1].abs = ifrom;}
 
     Lit          subsumes    (const Clause& other) const;
     void         strengthen  (Lit p);
-    void         setLBD(int i)  {header.lbd = i;} 
+    void         setLBD(int i)  {if (i < (1<<(BITS_LBD-1))) header.lbd = i; else header.lbd = (1<<(BITS_LBD-1));} 
     // unsigned int&       lbd    ()              { return header.lbd; }
     unsigned int        lbd    () const        { return header.lbd; }
     void setCanBeDel(bool b) {header.canbedel = b;}
     bool canBeDel() {return header.canbedel;}
+    void setSeen(bool b) {header.seen = b;}
+    bool getSeen() {return header.seen;}
+    void setExported(unsigned int b) {header.exported = b;}
+    unsigned int getExported() {return header.exported;}
+    void setOneWatched(bool b) {header.oneWatched = b;}
+    bool getOneWatched() {return header.oneWatched;}
     void setSizeWithoutSelectors   (unsigned int n)              {header.szWithoutSelectors = n; }
     unsigned int        sizeWithoutSelectors   () const        { return header.szWithoutSelectors; }
 
@@ -215,8 +270,8 @@ public:
 const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;
 class ClauseAllocator : public RegionAllocator<uint32_t>
 {
-    static int clauseWord32Size(int size, bool has_extra){
-        return (sizeof(Clause) + (sizeof(Lit) * (size + (int)has_extra))) / sizeof(uint32_t); }
+    static int clauseWord32Size(int size, int extra_size){
+        return (sizeof(Clause) + (sizeof(Lit) * (size + extra_size))) / sizeof(uint32_t); }
  public:
     bool extra_clause_field;
 
@@ -228,14 +283,15 @@ class ClauseAllocator : public RegionAll
         RegionAllocator<uint32_t>::moveTo(to); }
 
     template<class Lits>
-    CRef alloc(const Lits& ps, bool learnt = false)
+    CRef alloc(const Lits& ps, bool learnt = false, bool imported = false)
     {
         assert(sizeof(Lit)      == sizeof(uint32_t));
         assert(sizeof(float)    == sizeof(uint32_t));
+	
         bool use_extra = learnt | extra_clause_field;
-
-        CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), use_extra));
-        new (lea(cid)) Clause(ps, use_extra, learnt);
+        int extra_size = imported?3:(use_extra?1:0);
+        CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), extra_size));
+        new (lea(cid)) Clause(ps, extra_size, learnt);
 
         return cid;
     }
@@ -259,7 +315,7 @@ class ClauseAllocator : public RegionAll
         
         if (c.reloced()) { cr = c.relocation(); return; }
         
-        cr = to.alloc(c, c.learnt());
+        cr = to.alloc(c, c.learnt(), c.wasImported());
         c.relocate(cr);
         
         // Copy extra data-fields: 
@@ -268,8 +324,14 @@ class ClauseAllocator : public RegionAll
         if (to[cr].learnt())        {
 	  to[cr].activity() = c.activity();
 	  to[cr].setLBD(c.lbd());
+	  to[cr].setExported(c.getExported());
+	  to[cr].setOneWatched(c.getOneWatched());
+	  to[cr].setSeen(c.getSeen());
 	  to[cr].setSizeWithoutSelectors(c.sizeWithoutSelectors());
 	  to[cr].setCanBeDel(c.canBeDel());
+	  if (c.wasImported()) {
+             to[cr].setImportedFrom(c.importedFrom());
+	  }
 	}
         else if (to[cr].has_extra()) to[cr].calcAbstraction();
     }
@@ -296,6 +358,15 @@ class OccLists
     Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
 
     void  cleanAll  ();
+    void copyTo(OccLists &copy) const {
+	
+	copy.occs.growTo(occs.size());
+	for(int i = 0;i<occs.size();i++)
+	    occs[i].memCopyTo(copy.occs[i]);
+	dirty.memCopyTo(copy.dirty);
+	dirties.memCopyTo(copy.dirties);
+    }
+
     void  clean     (const Idx& idx);
     void  smudge    (const Idx& idx){
         if (dirty[toInt(idx)] == 0){
@@ -396,7 +467,7 @@ inline Lit Clause::subsumes(const Clause
     //if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
     //if (other.size() < size() || (!learnt() && !other.learnt() && (extra.abst & ~other.extra.abst) != 0))
     assert(!header.learnt);   assert(!other.header.learnt);
-    assert(header.has_extra); assert(other.header.has_extra);
+    assert(header.extra_size > 0); assert(other.header.extra_size > 0);
     if (other.header.size < header.size || (data[header.size].abs & ~other.data[other.header.size].abs) != 0)
         return lit_Error;
 
diff -rupN glucose-syrup/mtl/Alloc.h glucose-syrup.modified/mtl/Alloc.h
--- glucose-syrup/mtl/Alloc.h	2014-11-24 15:54:11.971436544 +0100
+++ glucose-syrup.modified/mtl/Alloc.h	2014-10-03 11:10:22.000000000 +0200
@@ -54,6 +54,7 @@ class RegionAllocator
 
 
     uint32_t size      () const      { return sz; }
+    uint32_t getCap    () const      { return cap;}
     uint32_t wasted    () const      { return wasted_; }
 
     Ref      alloc     (int size); 
@@ -79,6 +80,16 @@ class RegionAllocator
         sz = cap = wasted_ = 0;
     }
 
+    void copyTo(RegionAllocator& to) const {
+     //   if (to.memory != NULL) ::free(to.memory);
+        to.memory = (T*)xrealloc(to.memory, sizeof(T)*cap);
+        memcpy(to.memory,memory,sizeof(T)*cap);        
+        to.sz = sz;
+        to.cap = cap;
+        to.wasted_ = wasted_;
+    }
+
+
 
 };
 
diff -rupN glucose-syrup/mtl/Clone.h glucose-syrup.modified/mtl/Clone.h
--- glucose-syrup/mtl/Clone.h	1970-01-01 01:00:00.000000000 +0100
+++ glucose-syrup.modified/mtl/Clone.h	2014-10-03 11:10:22.000000000 +0200
@@ -0,0 +1,13 @@
+#ifndef Glucose_Clone_h
+#define Glucose_Clone_h
+
+
+namespace Glucose {
+
+    class Clone {
+        public:
+          virtual Clone* clone() const = 0;
+    };
+};
+
+#endif
\ No newline at end of file
diff -rupN glucose-syrup/mtl/Heap.h glucose-syrup.modified/mtl/Heap.h
--- glucose-syrup/mtl/Heap.h	2014-11-24 15:54:11.971436544 +0100
+++ glucose-syrup.modified/mtl/Heap.h	2014-10-03 11:10:22.000000000 +0200
@@ -41,6 +41,7 @@ class Heap {
     static inline int parent(int i) { return (i-1) >> 1; }
 
 
+
     void percolateUp(int i)
     {
         int x  = heap[i];
@@ -84,6 +85,7 @@ class Heap {
     void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }
     void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
 
+    void copyTo(Heap& copy) const {heap.copyTo(copy.heap);indices.copyTo(copy.indices);}
 
     // Safe variant of insert/decrease/increase:
     void update(int n)
diff -rupN glucose-syrup/mtl/Map.h glucose-syrup.modified/mtl/Map.h
--- glucose-syrup/mtl/Map.h	2014-11-24 15:54:11.971436544 +0100
+++ glucose-syrup.modified/mtl/Map.h	2014-12-06 11:48:39.116886400 +0100
@@ -29,17 +29,17 @@ namespace Glucose {
 // Default hash/equals functions
 //
 
+static inline uint32_t hash(uint32_t x){ return x; }
+static inline uint32_t hash(uint64_t x){ return (uint32_t)x; }
+static inline uint32_t hash(int32_t x) { return (uint32_t)x; }
+static inline uint32_t hash(int64_t x) { return (uint32_t)x; }
+
 template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };
 template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };
 
 template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };
 template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };
 
-static inline uint32_t hash(uint32_t x){ return x; }
-static inline uint32_t hash(uint64_t x){ return (uint32_t)x; }
-static inline uint32_t hash(int32_t x) { return (uint32_t)x; }
-static inline uint32_t hash(int64_t x) { return (uint32_t)x; }
-
 
 //=================================================================================================
 // Some primes
diff -rupN glucose-syrup/mtl/Queue.h glucose-syrup.modified/mtl/Queue.h
--- glucose-syrup/mtl/Queue.h	2014-11-24 15:54:11.971436544 +0100
+++ glucose-syrup.modified/mtl/Queue.h	2014-10-03 11:10:22.000000000 +0200
@@ -41,11 +41,22 @@ public:
     void clear (bool dealloc = false) { buf.clear(dealloc); buf.growTo(1); first = end = 0; }
     int  size  () const { return (end >= first) ? end - first : end - first + buf.size(); }
 
+    
+    
     const T& operator [] (int index) const  { assert(index >= 0); assert(index < size()); return buf[(first + index) % buf.size()]; }
     T&       operator [] (int index)        { assert(index >= 0); assert(index < size()); return buf[(first + index) % buf.size()]; }
 
     T    peek  () const { assert(first != end); return buf[first]; }
     void pop   () { assert(first != end); first++; if (first == buf.size()) first = 0; }
+    
+    
+    void copyTo(Queue<T>& copy) const {
+        copy.first = first;
+        copy.end = end;
+        buf.memCopyTo(copy.buf);
+    }
+    
+    
     void insert(T elem) {   // INVARIANT: buf[end] is always unused
         buf[end++] = elem;
         if (end == buf.size()) end = 0;
diff -rupN glucose-syrup/mtl/Vec.h glucose-syrup.modified/mtl/Vec.h
--- glucose-syrup/mtl/Vec.h	2014-11-24 16:14:01.075142808 +0100
+++ glucose-syrup.modified/mtl/Vec.h	2014-11-25 17:14:44.550232674 +0100
@@ -26,6 +26,7 @@ OF OR IN CONNECTION WITH THE SOFTWARE OR
 
 #include "mtl/IntTypes.h"
 #include "mtl/XAlloc.h"
+#include<string.h>
 
 namespace Glucose {
 
@@ -89,6 +90,12 @@ public:
     // Duplicatation (preferred instead):
     void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
     void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
+    void memCopyTo(vec<T>& copy) const{
+        copy.capacity(cap);
+        copy.sz = sz;
+        memcpy(copy.data,data,sizeof(T)*cap);
+    }
+
 };
 
 
@@ -96,7 +103,7 @@ template<class T>
 void vec<T>::capacity(int min_cap) {
     if (cap >= min_cap) return;
     int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
-    if (add > INT_MAX - cap || ( ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM ) )
+    if (add > INT_MAX - cap || (((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM))
         throw OutOfMemoryException();
  }
 
diff -rupN glucose-syrup/mtl/config.mk glucose-syrup.modified/mtl/config.mk
--- glucose-syrup/mtl/config.mk	2014-11-24 15:54:11.971436544 +0100
+++ glucose-syrup.modified/mtl/config.mk	1970-01-01 01:00:00.000000000 +0100
@@ -1,6 +0,0 @@
-##
-##  This file is for system specific configurations. For instance, on
-##  some systems the path to zlib needs to be added. Example:
-##
-##  CFLAGS += -I/usr/local/include
-##  LFLAGS += -L/usr/local/lib
diff -rupN glucose-syrup/mtl/template.mk glucose-syrup.modified/mtl/template.mk
--- glucose-syrup/mtl/template.mk	2014-11-24 15:54:11.971436544 +0100
+++ glucose-syrup.modified/mtl/template.mk	1970-01-01 01:00:00.000000000 +0100
@@ -1,107 +0,0 @@
-##
-##  Template makefile for Standard, Profile, Debug, Release, and Release-static versions
-##
-##    eg: "make rs" for a statically linked release version.
-##        "make d"  for a debug version (no optimizations).
-##        "make"    for the standard version (optimized, but with debug information and assertions active)
-
-PWD        = $(shell pwd)
-EXEC      ?= $(notdir $(PWD))
-
-CSRCS      = $(wildcard $(PWD)/*.cc) 
-DSRCS      = $(foreach dir, $(DEPDIR), $(filter-out $(MROOT)/$(dir)/Main.cc, $(wildcard $(MROOT)/$(dir)/*.cc)))
-CHDRS      = $(wildcard $(PWD)/*.h)
-COBJS      = $(CSRCS:.cc=.o) $(DSRCS:.cc=.o)
-
-PCOBJS     = $(addsuffix p,  $(COBJS))
-DCOBJS     = $(addsuffix d,  $(COBJS))
-RCOBJS     = $(addsuffix r,  $(COBJS))
-
-
-CXX       ?= g++
-CFLAGS    ?= -Wall -Wno-parentheses
-LFLAGS    ?= -Wall
-
-COPTIMIZE ?= -O3
-
-CFLAGS    += -I$(MROOT) -D __STDC_LIMIT_MACROS -D __STDC_FORMAT_MACROS
-LFLAGS    += -lz
-
-.PHONY : s p d r rs clean 
-
-s:	$(EXEC)
-p:	$(EXEC)_profile
-d:	$(EXEC)_debug
-r:	$(EXEC)_release
-rs:	$(EXEC)_static
-
-libs:	lib$(LIB)_standard.a
-libp:	lib$(LIB)_profile.a
-libd:	lib$(LIB)_debug.a
-libr:	lib$(LIB)_release.a
-
-## Compile options
-%.o:			CFLAGS +=$(COPTIMIZE) -g -D DEBUG
-%.op:			CFLAGS +=$(COPTIMIZE) -pg -g -D NDEBUG
-%.od:			CFLAGS +=-O0 -g -D DEBUG
-%.or:			CFLAGS +=$(COPTIMIZE) -g -D NDEBUG
-
-## Link options
-$(EXEC):		LFLAGS += -g
-$(EXEC)_profile:	LFLAGS += -g -pg
-$(EXEC)_debug:		LFLAGS += -g
-#$(EXEC)_release:	LFLAGS += ...
-$(EXEC)_static:		LFLAGS += --static
-
-## Dependencies
-$(EXEC):		$(COBJS)
-$(EXEC)_profile:	$(PCOBJS)
-$(EXEC)_debug:		$(DCOBJS)
-$(EXEC)_release:	$(RCOBJS)
-$(EXEC)_static:		$(RCOBJS)
-
-lib$(LIB)_standard.a:	$(filter-out */Main.o,  $(COBJS))
-lib$(LIB)_profile.a:	$(filter-out */Main.op, $(PCOBJS))
-lib$(LIB)_debug.a:	$(filter-out */Main.od, $(DCOBJS))
-lib$(LIB)_release.a:	$(filter-out */Main.or, $(RCOBJS))
-
-
-## Build rule
-%.o %.op %.od %.or:	%.cc
-	@echo Compiling: $(subst $(MROOT)/,,$@)
-	@$(CXX) $(CFLAGS) -c -o $@ $<
-
-## Linking rules (standard/profile/debug/release)
-$(EXEC) $(EXEC)_profile $(EXEC)_debug $(EXEC)_release $(EXEC)_static:
-	@echo Linking: "$@ ( $(foreach f,$^,$(subst $(MROOT)/,,$f)) )"
-	@$(CXX) $^ $(LFLAGS) -o $@
-
-## Library rules (standard/profile/debug/release)
-lib$(LIB)_standard.a lib$(LIB)_profile.a lib$(LIB)_release.a lib$(LIB)_debug.a:
-	@echo Making library: "$@ ( $(foreach f,$^,$(subst $(MROOT)/,,$f)) )"
-	@$(AR) -rcsv $@ $^
-
-## Library Soft Link rule:
-libs libp libd libr:
-	@echo "Making Soft Link: $^ -> lib$(LIB).a"
-	@ln -sf $^ lib$(LIB).a
-
-## Clean rule
-clean:
-	@rm -f $(EXEC) $(EXEC)_profile $(EXEC)_debug $(EXEC)_release $(EXEC)_static \
-	  $(COBJS) $(PCOBJS) $(DCOBJS) $(RCOBJS) *.core depend.mk 
-
-## Make dependencies
-depend.mk: $(CSRCS) $(CHDRS)
-	@echo Making dependencies
-	@$(CXX) $(CFLAGS) -I$(MROOT) \
-	   $(CSRCS) -MM | sed 's|\(.*\):|$(PWD)/\1 $(PWD)/\1r $(PWD)/\1d $(PWD)/\1p:|' > depend.mk
-	@for dir in $(DEPDIR); do \
-	      if [ -r $(MROOT)/$${dir}/depend.mk ]; then \
-		  echo Depends on: $${dir}; \
-		  cat $(MROOT)/$${dir}/depend.mk >> depend.mk; \
-	      fi; \
-	  done
-
--include $(MROOT)/mtl/config.mk
--include depend.mk
diff -rupN glucose-syrup/simp/Main.cc.disabled glucose-syrup.modified/simp/Main.cc.disabled
--- glucose-syrup/simp/Main.cc.disabled	2014-11-24 15:54:11.975436624 +0100
+++ glucose-syrup.modified/simp/Main.cc.disabled	1970-01-01 01:00:00.000000000 +0100
@@ -1,211 +0,0 @@
-/*****************************************************************************************[Main.cc]
-Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
-Copyright (c) 2007,      Niklas Sorensson
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-associated documentation files (the "Software"), to deal in the Software without restriction,
-including without limitation the rights to use, copy, modify, merge, publish, distribute,
-sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all copies or
-substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
-OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-**************************************************************************************************/
-
-#include <errno.h>
-
-#include <signal.h>
-#include <zlib.h>
-#include <sys/resource.h>
-
-#include "utils/System.h"
-#include "utils/ParseUtils.h"
-#include "utils/Options.h"
-#include "core/Dimacs.h"
-#include "simp/SimpSolver.h"
-
-using namespace Minisat;
-
-//=================================================================================================
-
-
-void printStats(Solver& solver)
-{
-    double cpu_time = cpuTime();
-    double mem_used = memUsedPeak();
-    printf("restarts              : %"PRIu64"\n", solver.starts);
-    printf("conflicts             : %-12"PRIu64"   (%.0f /sec)\n", solver.conflicts   , solver.conflicts   /cpu_time);
-    printf("decisions             : %-12"PRIu64"   (%4.2f %% random) (%.0f /sec)\n", solver.decisions, (float)solver.rnd_decisions*100 / (float)solver.decisions, solver.decisions   /cpu_time);
-    printf("propagations          : %-12"PRIu64"   (%.0f /sec)\n", solver.propagations, solver.propagations/cpu_time);
-    printf("conflict literals     : %-12"PRIu64"   (%4.2f %% deleted)\n", solver.tot_literals, (solver.max_literals - solver.tot_literals)*100 / (double)solver.max_literals);
-    if (mem_used != 0) printf("Memory used           : %.2f MB\n", mem_used);
-    printf("CPU time              : %g s\n", cpu_time);
-}
-
-
-static Solver* solver;
-// Terminate by notifying the solver and back out gracefully. This is mainly to have a test-case
-// for this feature of the Solver as it may take longer than an immediate call to '_exit()'.
-static void SIGINT_interrupt(int signum) { solver->interrupt(); }
-
-// Note that '_exit()' rather than 'exit()' has to be used. The reason is that 'exit()' calls
-// destructors and may cause deadlocks if a malloc/free function happens to be running (these
-// functions are guarded by locks for multithreaded use).
-static void SIGINT_exit(int signum) {
-    printf("\n"); printf("*** INTERRUPTED ***\n");
-    if (solver->verbosity > 0){
-        printStats(*solver);
-        printf("\n"); printf("*** INTERRUPTED ***\n"); }
-    _exit(1); }
-
-
-//=================================================================================================
-// Main:
-
-int main(int argc, char** argv)
-{
-    try {
-        setUsageHelp("USAGE: %s [options] <input-file> <result-output-file>\n\n  where input may be either in plain or gzipped DIMACS.\n");
-        // printf("This is MiniSat 2.0 beta\n");
-        
-#if defined(__linux__)
-        fpu_control_t oldcw, newcw;
-        _FPU_GETCW(oldcw); newcw = (oldcw & ~_FPU_EXTENDED) | _FPU_DOUBLE; _FPU_SETCW(newcw);
-        printf("WARNING: for repeatability, setting FPU to use double precision\n");
-#endif
-        // Extra options:
-        //
-        IntOption    verb   ("MAIN", "verb",   "Verbosity level (0=silent, 1=some, 2=more).", 1, IntRange(0, 2));
-        BoolOption   pre    ("MAIN", "pre",    "Completely turn on/off any preprocessing.", true);
-        StringOption dimacs ("MAIN", "dimacs", "If given, stop after preprocessing and write the result to this file.");
-        IntOption    cpu_lim("MAIN", "cpu-lim","Limit on CPU time allowed in seconds.\n", INT32_MAX, IntRange(0, INT32_MAX));
-        IntOption    mem_lim("MAIN", "mem-lim","Limit on memory usage in megabytes.\n", INT32_MAX, IntRange(0, INT32_MAX));
-
-        parseOptions(argc, argv, true);
-        
-        SimpSolver  S;
-        double      initial_time = cpuTime();
-
-        if (!pre) S.eliminate(true);
-
-        S.verbosity = verb;
-        
-        solver = &S;
-        // Use signal handlers that forcibly quit until the solver will be able to respond to
-        // interrupts:
-        signal(SIGINT, SIGINT_exit);
-        signal(SIGXCPU,SIGINT_exit);
-
-        // Set limit on CPU-time:
-        if (cpu_lim != INT32_MAX){
-            rlimit rl;
-            getrlimit(RLIMIT_CPU, &rl);
-            if (rl.rlim_max == RLIM_INFINITY || (rlim_t)cpu_lim < rl.rlim_max){
-                rl.rlim_cur = cpu_lim;
-                if (setrlimit(RLIMIT_CPU, &rl) == -1)
-                    printf("WARNING! Could not set resource limit: CPU-time.\n");
-            } }
-
-        // Set limit on virtual memory:
-        if (mem_lim != INT32_MAX){
-            rlim_t new_mem_lim = (rlim_t)mem_lim * 1024*1024;
-            rlimit rl;
-            getrlimit(RLIMIT_AS, &rl);
-            if (rl.rlim_max == RLIM_INFINITY || new_mem_lim < rl.rlim_max){
-                rl.rlim_cur = new_mem_lim;
-                if (setrlimit(RLIMIT_AS, &rl) == -1)
-                    printf("WARNING! Could not set resource limit: Virtual memory.\n");
-            } }
-        
-        if (argc == 1)
-            printf("Reading from standard input... Use '--help' for help.\n");
-
-        gzFile in = (argc == 1) ? gzdopen(0, "rb") : gzopen(argv[1], "rb");
-        if (in == NULL)
-            printf("ERROR! Could not open file: %s\n", argc == 1 ? "<stdin>" : argv[1]), exit(1);
-        
-        if (S.verbosity > 0){
-            printf("============================[ Problem Statistics ]=============================\n");
-            printf("|                                                                             |\n"); }
-        
-        parse_DIMACS(in, S);
-        gzclose(in);
-        FILE* res = (argc >= 3) ? fopen(argv[2], "wb") : NULL;
-
-        if (S.verbosity > 0){
-            printf("|  Number of variables:  %12d                                         |\n", S.nVars());
-            printf("|  Number of clauses:    %12d                                         |\n", S.nClauses()); }
-        
-        double parsed_time = cpuTime();
-        if (S.verbosity > 0)
-            printf("|  Parse time:           %12.2f s                                       |\n", parsed_time - initial_time);
-
-        // Change to signal-handlers that will only notify the solver and allow it to terminate
-        // voluntarily:
-        signal(SIGINT, SIGINT_interrupt);
-        signal(SIGXCPU,SIGINT_interrupt);
-
-        S.eliminate(true);
-        double simplified_time = cpuTime();
-        if (S.verbosity > 0){
-            printf("|  Simplification time:  %12.2f s                                       |\n", simplified_time - parsed_time);
-            printf("|                                                                             |\n"); }
-
-        if (!S.okay()){
-            if (res != NULL) fprintf(res, "UNSAT\n"), fclose(res);
-            if (S.verbosity > 0){
-                printf("===============================================================================\n");
-                printf("Solved by simplification\n");
-                printStats(S);
-                printf("\n"); }
-            printf("UNSATISFIABLE\n");
-            exit(20);
-        }
-
-        if (dimacs){
-            if (S.verbosity > 0)
-                printf("==============================[ Writing DIMACS ]===============================\n");
-            S.toDimacs((const char*)dimacs);
-            if (S.verbosity > 0)
-                printStats(S);
-            exit(0);
-        }
-
-        vec<Lit> dummy;
-        lbool ret = S.solveLimited(dummy);
-        
-        if (S.verbosity > 0){
-            printStats(S);
-            printf("\n"); }
-        printf(ret == l_True ? "SATISFIABLE\n" : ret == l_False ? "UNSATISFIABLE\n" : "INDETERMINATE\n");
-        if (res != NULL){
-            if (ret == l_True){
-                fprintf(res, "SAT\n");
-                for (int i = 0; i < S.nVars(); i++)
-                    if (S.model[i] != l_Undef)
-                        fprintf(res, "%s%s%d", (i==0)?"":" ", (S.model[i]==l_True)?"":"-", i+1);
-                fprintf(res, " 0\n");
-            }else if (ret == l_False)
-                fprintf(res, "UNSAT\n");
-            else
-                fprintf(res, "INDET\n");
-            fclose(res);
-        }
-
-#ifdef NDEBUG
-        exit(ret == l_True ? 10 : ret == l_False ? 20 : 0);     // (faster than "return", which will invoke the destructor for 'Solver')
-#else
-        return (ret == l_True ? 10 : ret == l_False ? 20 : 0);
-#endif
-    } catch (OutOfMemoryException&){
-        printf("===============================================================================\n");
-        printf("INDETERMINATE\n");
-        exit(0);
-    }
-}
diff -rupN glucose-syrup/simp/Makefile glucose-syrup.modified/simp/Makefile
--- glucose-syrup/simp/Makefile	2014-11-24 15:54:11.975436624 +0100
+++ glucose-syrup.modified/simp/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-EXEC      = minisat
-DEPDIR    = mtl utils core
-
-include $(MROOT)/mtl/template.mk
diff -rupN glucose-syrup/simp/SimpSolver.cc glucose-syrup.modified/simp/SimpSolver.cc
--- glucose-syrup/simp/SimpSolver.cc	2014-11-24 16:18:56.557018083 +0100
+++ glucose-syrup.modified/simp/SimpSolver.cc	2014-11-25 17:14:44.558232550 +0100
@@ -1,5 +1,34 @@
-/***********************************************************************************[SimpSolver.cc]
-Copyright (c) 2006,      Niklas Een, Niklas Sorensson
+/***************************************************************************************[SimpSolver.cc]
+ Glucose -- Copyright (c) 2009-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                LRI  - Univ. Paris Sud, France (2009-2013)
+                                Labri - Univ. Bordeaux, France
+
+ Syrup (Glucose Parallel) -- Copyright (c) 2013-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                Labri - Univ. Bordeaux, France
+
+Glucose sources are based on MiniSat (see below MiniSat copyrights). Permissions and copyrights of
+Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it 
+is based on. (see below).
+
+Glucose-Syrup sources are based on another copyright. Permissions and copyrights for the parallel
+version of Glucose-Syrup (the "Software") are granted, free of charge, to deal with the Software
+without restriction, including the rights to use, copy, modify, merge, publish, distribute,
+sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is 
+furnished to do so, subject to the following conditions:
+
+- The above and below copyrights notices and this permission notice shall be included in all
+copies or substantial portions of the Software;
+- The parallel version of Glucose (all files modified since Glucose 3.0 releases, 2013) cannot
+be used in any competitive event (sat competitions/evaluations) without the express permission of 
+the authors (Gilles Audemard / Laurent Simon). This is also the case for any competitive event
+using Glucose Parallel as an embedded SAT engine (single core or not).
+
+
+--------------- Original Minisat Copyrights
+
+Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
 Copyright (c) 2007-2010, Niklas Sorensson
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
@@ -16,7 +45,7 @@ NOT LIMITED TO THE WARRANTIES OF MERCHAN
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-**************************************************************************************************/
+ **************************************************************************************************/
 
 #include "mtl/Sort.h"
 #include "simp/SimpSolver.h"
@@ -44,7 +73,8 @@ static DoubleOption opt_simp_garbage_fra
 
 
 SimpSolver::SimpSolver() :
-    grow               (opt_grow)
+   Solver()
+  , grow               (opt_grow)
   , clause_lim         (opt_clause_lim)
   , subsumption_lim    (opt_subsumption_lim)
   , simp_garbage_frac  (opt_simp_garbage_frac)
@@ -73,9 +103,54 @@ SimpSolver::~SimpSolver()
 }
 
 
+
+SimpSolver::SimpSolver(const SimpSolver &s) : Solver(s)
+  , grow               (s.grow)
+  , clause_lim         (s.clause_lim)
+  , subsumption_lim    (s.subsumption_lim)
+  , simp_garbage_frac  (s.simp_garbage_frac)
+  , use_asymm          (s.use_asymm)
+  , use_rcheck         (s.use_rcheck)
+  , use_elim           (s.use_elim)
+  , merges             (s.merges)
+  , asymm_lits         (s.asymm_lits)
+  , eliminated_vars    (s.eliminated_vars)
+  , elimorder          (s.elimorder)
+  , use_simplification (s.use_simplification)
+  , occurs             (ClauseDeleted(ca))
+  , elim_heap          (ElimLt(n_occ))
+  , bwdsub_assigns     (s.bwdsub_assigns)
+  , n_touched          (s.n_touched)
+{
+    // TODO: Copy dummy... what is it???
+    vec<Lit> dummy(1,lit_Undef);
+    ca.extra_clause_field = true; // NOTE: must happen before allocating the dummy clause below.
+    bwdsub_tmpunit        = ca.alloc(dummy);
+    remove_satisfied      = false;
+    //End TODO  
+    
+    
+    s.elimclauses.memCopyTo(elimclauses);
+    s.touched.memCopyTo(touched);
+    s.occurs.copyTo(occurs);
+    s.n_occ.memCopyTo(n_occ);
+    s.elim_heap.copyTo(elim_heap);
+    s.subsumption_queue.copyTo(subsumption_queue);
+    s.frozen.memCopyTo(frozen);
+    s.eliminated.memCopyTo(eliminated);
+
+    use_simplification = s.use_simplification;
+    bwdsub_assigns = s.bwdsub_assigns;
+    n_touched = s.n_touched;
+    bwdsub_tmpunit = s.bwdsub_tmpunit;
+    qhead = s.qhead;
+    ok = s.ok;
+}
+
+
+
 Var SimpSolver::newVar(bool sign, bool dvar) {
     Var v = Solver::newVar(sign, dvar);
-
     frozen    .push((char)false);
     eliminated.push((char)false);
 
@@ -88,13 +163,10 @@ Var SimpSolver::newVar(bool sign, bool d
     }
     return v; }
 
-
-
 lbool SimpSolver::solve_(bool do_simp, bool turn_off_simp)
 {
     vec<Var> extra_frozen;
     lbool    result = l_True;
-
     do_simp &= use_simplification;
 
     if (do_simp){
@@ -116,8 +188,8 @@ lbool SimpSolver::solve_(bool do_simp, b
 
     if (result == l_True)
         result = Solver::solve_();
-    else if (verbosity >= 1)
-        printf("===============================================================================\n");
+//    else if (verbosity >= 1)
+//        printf("===============================================================================\n");
 
     if (result == l_True)
         extendModel();
@@ -127,6 +199,7 @@ lbool SimpSolver::solve_(bool do_simp, b
         for (int i = 0; i < extra_frozen.size(); i++)
             setFrozen(extra_frozen[i], false);
 
+
     return result;
 }
 
@@ -177,7 +250,8 @@ bool SimpSolver::addClause_(vec<Lit>& ps
 }
 
 
-void SimpSolver::removeClause(CRef cr)
+
+void SimpSolver::removeClause(CRef cr,bool inPurgatory)
 {
     const Clause& c = ca[cr];
 
@@ -188,7 +262,7 @@ void SimpSolver::removeClause(CRef cr)
             occurs.smudge(var(c[i]));
         }
 
-    Solver::removeClause(cr);
+    Solver::removeClause(cr,inPurgatory);
 }
 
 
@@ -343,9 +417,9 @@ bool SimpSolver::implied(const vec<Lit>&
 
 
 // Backward subsumption + backward subsumption resolution
-bool SimpSolver::backwardSubsumptionCheck(bool verbose)
+bool SimpSolver::backwardSubsumptionCheck(bool)
 {
-    int cnt = 0;
+//    int cnt = 0;
     int subsumed = 0;
     int deleted_literals = 0;
     assert(decisionLevel() == 0);
@@ -370,8 +444,8 @@ bool SimpSolver::backwardSubsumptionChec
 
         if (c.mark()) continue;
 
-        if (verbose && verbosity >= 2 && cnt++ % 1000 == 0)
-            printf("subsumption left: %10d (%10d subsumed, %10d deleted literals)\r", subsumption_queue.size(), subsumed, deleted_literals);
+//        if (verbose && verbosity >= 2 && cnt++ % 1000 == 0)
+//            printf("subsumption left: %10d (%10d subsumed, %10d deleted literals)\r", subsumption_queue.size(), subsumed, deleted_literals);
 
         assert(c.size() > 1 || value(c[0]) == l_True);    // Unit-clauses should have been propagated before this point.
 
@@ -588,6 +662,8 @@ void SimpSolver::extendModel()
     int i, j;
     Lit x;
 
+    if(model.size()==0) model.growTo(nVars());
+    
     for (i = elimclauses.size()-1; i > 0; i -= j){
         for (j = elimclauses[i--]; j > 1; j--, i--)
             if (modelValue(toLit(elimclauses[i])) != l_False)
@@ -602,8 +678,10 @@ void SimpSolver::extendModel()
 
 bool SimpSolver::eliminate(bool turn_off_elim)
 {
-    if (!simplify())
+    if (!simplify()) {
+        ok = false;
         return false;
+    }
     else if (!use_simplification)
         return true;
 
@@ -640,8 +718,8 @@ bool SimpSolver::eliminate(bool turn_off
 
             if (isEliminated(elim) || value(elim) != l_Undef) continue;
 
-            if (verbosity >= 2 && cnt % 100 == 0)
-                printf("elimination left: %10d\r", elim_heap.size());
+//            if (verbosity >= 2 && cnt % 100 == 0)
+//                printf("elimination left: %10d\r", elim_heap.size());
 
             if (use_asymm){
                 // Temporarily freeze variable. Otherwise, it would immediately end up on the queue again:
@@ -684,11 +762,14 @@ bool SimpSolver::eliminate(bool turn_off
         checkGarbage();
     }
 
-    if (verbosity >= 1 && elimclauses.size() > 0)
-        printf("c |  Eliminated clauses:     %10.2f Mb                                                                |\n", 
-               double(elimclauses.size() * sizeof(uint32_t)) / (1024*1024));
+//    if (verbosity >= 0 && elimclauses.size() > 0)
+//        printf("c |  Eliminated clauses:     %10.2f Mb                                                                |\n", 
+//               double(elimclauses.size() * sizeof(uint32_t)) / (1024*1024));
 
+               
     return ok;
+
+    
 }
 
 
@@ -740,8 +821,8 @@ void SimpSolver::garbageCollect()
     to.extra_clause_field = ca.extra_clause_field; // NOTE: this is important to keep (or lose) the extra fields.
     relocAll(to);
     Solver::relocAll(to);
-    if (verbosity >= 2)
-        printf("|  Garbage collection:   %12d bytes => %12d bytes             |\n", 
-               ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
+//    if (verbosity >= 2)
+//        printf("|  Garbage collection:   %12d bytes => %12d bytes             |\n", 
+//               ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
     to.moveTo(ca);
 }
diff -rupN glucose-syrup/simp/SimpSolver.h glucose-syrup.modified/simp/SimpSolver.h
--- glucose-syrup/simp/SimpSolver.h	2014-11-24 15:54:11.975436624 +0100
+++ glucose-syrup.modified/simp/SimpSolver.h	2014-10-03 11:10:22.000000000 +0200
@@ -1,5 +1,34 @@
-/************************************************************************************[SimpSolver.h]
-Copyright (c) 2006,      Niklas Een, Niklas Sorensson
+/***************************************************************************************[SimpSolver.h]
+ Glucose -- Copyright (c) 2009-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                LRI  - Univ. Paris Sud, France (2009-2013)
+                                Labri - Univ. Bordeaux, France
+
+ Syrup (Glucose Parallel) -- Copyright (c) 2013-2014, Gilles Audemard, Laurent Simon
+                                CRIL - Univ. Artois, France
+                                Labri - Univ. Bordeaux, France
+
+Glucose sources are based on MiniSat (see below MiniSat copyrights). Permissions and copyrights of
+Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it 
+is based on. (see below).
+
+Glucose-Syrup sources are based on another copyright. Permissions and copyrights for the parallel
+version of Glucose-Syrup (the "Software") are granted, free of charge, to deal with the Software
+without restriction, including the rights to use, copy, modify, merge, publish, distribute,
+sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is 
+furnished to do so, subject to the following conditions:
+
+- The above and below copyrights notices and this permission notice shall be included in all
+copies or substantial portions of the Software;
+- The parallel version of Glucose (all files modified since Glucose 3.0 releases, 2013) cannot
+be used in any competitive event (sat competitions/evaluations) without the express permission of 
+the authors (Gilles Audemard / Laurent Simon). This is also the case for any competitive event
+using Glucose Parallel as an embedded SAT engine (single core or not).
+
+
+--------------- Original Minisat Copyrights
+
+Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
 Copyright (c) 2007-2010, Niklas Sorensson
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
@@ -16,14 +45,14 @@ NOT LIMITED TO THE WARRANTIES OF MERCHAN
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-**************************************************************************************************/
+ **************************************************************************************************/
 
 #ifndef Glucose_SimpSolver_h
 #define Glucose_SimpSolver_h
 
 #include "mtl/Queue.h"
 #include "core/Solver.h"
-
+#include "mtl/Clone.h"
 
 namespace Glucose {
 
@@ -36,16 +65,27 @@ class SimpSolver : public Solver {
     //
     SimpSolver();
     ~SimpSolver();
+    
+    SimpSolver(const  SimpSolver &s);
+    
+
+    /**
+     * Clone function
+    */
+    virtual Clone* clone() const {
+        return  new SimpSolver(*this);
+    }   
 
+    
     // Problem specification:
     //
-    Var     newVar    (bool polarity = true, bool dvar = true);
+    virtual Var     newVar    (bool polarity = true, bool dvar = true); // Add a new variable with parameters specifying variable mode.
     bool    addClause (const vec<Lit>& ps);
     bool    addEmptyClause();                // Add the empty clause to the solver.
     bool    addClause (Lit p);               // Add a unit clause to the solver.
     bool    addClause (Lit p, Lit q);        // Add a binary clause to the solver.
     bool    addClause (Lit p, Lit q, Lit r); // Add a ternary clause to the solver.
-    bool    addClause_(      vec<Lit>& ps);
+    virtual bool    addClause_(      vec<Lit>& ps);
     bool    substitute(Var v, Lit x);  // Replace all occurences of v with x (may cause a contradiction).
 
     // Variable mode:
@@ -90,7 +130,6 @@ class SimpSolver : public Solver {
     bool    use_asymm;         // Shrink clauses by asymmetric branching.
     bool    use_rcheck;        // Check if a clause is already implied. Prett costly, and subsumes subsumptions :)
     bool    use_elim;          // Perform variable elimination.
-
     // Statistics:
     //
     int     merges;
@@ -144,7 +183,7 @@ class SimpSolver : public Solver {
 
     // Main internal methods:
     //
-    lbool         solve_                   (bool do_simp = true, bool turn_off_simp = false);
+    virtual lbool         solve_                   (bool do_simp = true, bool turn_off_simp = false);
     bool          asymm                    (Var v, CRef cr);
     bool          asymmVar                 (Var v);
     void          updateElimHeap           (Var v);
@@ -155,11 +194,11 @@ class SimpSolver : public Solver {
     bool          eliminateVar             (Var v);
     void          extendModel              ();
 
-    void          removeClause             (CRef cr);
+    void          removeClause             (CRef cr,bool inPurgatory=false);
     bool          strengthenClause         (CRef cr, Lit l);
     void          cleanUpClauses           ();
     bool          implied                  (const vec<Lit>& c);
-    void          relocAll                 (ClauseAllocator& to);
+    virtual void          relocAll                 (ClauseAllocator& to);
 };
 
 
diff -rupN glucose-syrup/utils/Makefile glucose-syrup.modified/utils/Makefile
--- glucose-syrup/utils/Makefile	2014-11-24 15:54:11.975436624 +0100
+++ glucose-syrup.modified/utils/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-EXEC      = system_test
-DEPDIR    = mtl
-
-include $(MROOT)/mtl/template.mk
diff -rupN glucose-syrup/utils/Options.cc glucose-syrup.modified/utils/Options.cc
--- glucose-syrup/utils/Options.cc	2014-11-24 16:15:19.176697423 +0100
+++ glucose-syrup.modified/utils/Options.cc	2014-11-25 17:14:44.558232550 +0100
@@ -57,7 +57,7 @@ void Glucose::parseOptions(int& argc, ch
 
 void Glucose::setUsageHelp      (const char* str){ Option::getUsageString() = str; }
 void Glucose::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }
-void Glucose::printUsageAndExit (int , char** argv, bool verbose)
+void Glucose::printUsageAndExit (int, char** argv, bool verbose)
 {
     const char* usage = Option::getUsageString();
     if (usage != NULL)
diff -rupN glucose-syrup/utils/Options.h glucose-syrup.modified/utils/Options.h
--- glucose-syrup/utils/Options.h	2014-11-24 16:12:47.633678044 +0100
+++ glucose-syrup.modified/utils/Options.h	2014-11-25 17:14:44.558232550 +0100
@@ -60,7 +60,7 @@ class Option
     struct OptionLt {
         bool operator()(const Option* x, const Option* y) {
             int test1 = strcmp(x->category, y->category);
-            return test1 < 0 || ( test1 == 0 && strcmp(x->type_name, y->type_name) < 0 );
+            return test1 < 0 || (test1 == 0 && strcmp(x->type_name, y->type_name) < 0);
         }
     };
 
@@ -282,15 +282,15 @@ class Int64Option : public Option
         if (range.begin == INT64_MIN)
             fprintf(stderr, "imin");
         else
-            fprintf(stderr, "%4"PRIi64, range.begin);
+            fprintf(stderr, "%4" PRIi64, range.begin);
 
         fprintf(stderr, " .. ");
         if (range.end == INT64_MAX)
             fprintf(stderr, "imax");
         else
-            fprintf(stderr, "%4"PRIi64, range.end);
+            fprintf(stderr, "%4" PRIi64, range.end);
 
-        fprintf(stderr, "] (default: %"PRIi64")\n", value);
+        fprintf(stderr, "] (default: %" PRIi64")\n", value);
         if (verbose){
             fprintf(stderr, "\n        %s\n", description);
             fprintf(stderr, "\n");
diff -rupN glucose-syrup/utils/System.h glucose-syrup.modified/utils/System.h
--- glucose-syrup/utils/System.h	2014-11-24 15:54:11.975436624 +0100
+++ glucose-syrup.modified/utils/System.h	2014-10-03 11:10:22.000000000 +0200
@@ -32,6 +32,7 @@ OF OR IN CONNECTION WITH THE SOFTWARE OR
 namespace Glucose {
 
 static inline double cpuTime(void); // CPU-time in seconds.
+static inline double realTime(void);
 extern double memUsed();            // Memory in mega bytes (returns 0 for unsupported architectures).
 extern double memUsedPeak();        // Peak-memory in mega bytes (returns 0 for unsupported architectures).
 
@@ -57,4 +58,10 @@ static inline double Glucose::cpuTime(vo
 
 #endif
 
+// Laurent: I know that this will not compile directly under Windows... sorry for that
+static inline double Glucose::realTime() {
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+    return (double)tv.tv_sec + (double) tv.tv_usec / 1000000; }
+
 #endif
